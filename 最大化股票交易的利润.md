最大化股票交易的利润

### 题目描述

实现一个算法寻找最大化股票交易利润的策略。介绍如下：

- 股票价格每天都在变化，以数组的索引表示交易日，以数组的元素表示每天的股票价格。
- 可以通过买入和卖出获得利润。一天只能进行一次买入或卖出操作，一次买入加卖出操作称为一次交易次数。
- 你只能交易一次，求使得利润最大的交易策略。

### 输入描述

第一行为数字 N*N*，表示共有 N*N* 天。

第二行为 N*N* 个数字 Ai*A**i*，表示每天的股票价格。

其中，1≤N,Ai≤1041≤*N*,*A**i*≤104。

### 输出描述

输出一行，为交易一次的最大利润（有可能利润为负）。

### 输入输出样例

#### 示例

> 输入

```txt
8
2 5 6 1 4 3 1 3
```

> 输出

```txt
4
```





好，这一步**先不写代码，只把题目“吃透”**，这是非常正确的做法 👍
我会用**直观 + 例子 + 规则拆解**的方式带你理解。

------

## 一、这道题到底在干什么？

一句话总结：

> **在一堆每天的股票价格中，选择“某一天买入、之后某一天卖出”，只做一次交易，让赚的钱最多。**

------

## 二、题目给了哪些“规则限制”？

我们一条一条拆开来看 👇

### 1️⃣ 股票价格怎么给的？

- 用一个数组表示
- **下标 = 第几天**
- **数组里的数 = 当天价格**

例如：

```
下标（天数）： 0  1  2  3  4  5  6  7
价格：         2  5  6  1  4  3  1  3
```

------

### 2️⃣ 什么是“一次交易”？

题目明确说：

> **一次买入 + 一次卖出 = 一次交易**

而且：

- 一天只能做一个动作（买 或 卖）
- **只能交易一次**

⚠️ 这意味着：

- 不能买了卖、再买再卖
- **只能选一个买入日 + 一个卖出日**

------

### 3️⃣ 买卖顺序非常重要 ⚠️

这是很多人第一次容易忽略的点：

> **必须先买，才能卖**

也就是说：

- 买入日的下标 **必须小于** 卖出日的下标

❌ 不允许：

- 先卖后买
- 同一天买卖（没意义）

------

## 三、什么叫“利润”？

利润的计算方式是：

```
利润 = 卖出价格 - 买入价格
```

### 举例：

- 第 0 天买（2）
- 第 2 天卖（6）

利润 = `6 - 2 = 4`

------

### 重点 ❗：利润可以是负的

题目特别说明了：

> **有可能利润为负**

这意味着：

- 如果股票一直在跌
- 你“被迫”选一次交易
- 那就选一个 **亏得最少的**

例如：

```
价格： 9 7 5 3
```

最优策略：

- 9 买
- 7 卖
  利润 = -2（虽然亏，但已经是最优）

------

## 四、用样例完整走一遍思路

### 输入：

```
8
2 5 6 1 4 3 1 3
```

我们要做的事情其实就是：

> **在所有“前低后高”的组合中，找一个差值最大的**

------

### 尝试一些可能的交易：

| 买入日 | 买入价 | 卖出日 | 卖出价 | 利润 |
| ------ | ------ | ------ | ------ | ---- |
| 0      | 2      | 1      | 5      | 3    |
| 0      | 2      | 2      | 6      | 4 ✅  |
| 3      | 1      | 4      | 4      | 3    |
| 6      | 1      | 7      | 3      | 2    |

最大利润是 **4**

所以输出：

```
4
```

------

## 五、这道题本质在考什么？

如果站在算法角度来看，它在考你：

### 🔍 核心问题

> **在遍历价格的过程中，如何记住“历史最低价”，并计算当前卖出能赚多少？**

你其实是在不断问自己一句话：

> “如果我今天卖掉，**之前最便宜是哪一天买的？**”

------

## 六、你现在需要牢牢记住的三句话

👉 **这是理解本题的关键**

1️⃣ 只能做 **一次买 + 一次卖**
2️⃣ **先买后卖**，顺序不能反
3️⃣ 找到 **卖出价 − 之前最低买入价 的最大值**

------

如果你愿意，下一步我可以：

- 用 **暴力思路 → 优化思路**带你推导算法
- 或者用 **“每天脑子里在想什么”**的方式模拟思考过程
- 再或者用 **图示 + 动态变化**帮你彻底建立直觉

你想从哪一步继续？好，现在在你已经**完全理解题意**的基础上，我们来给出一份**完整、规范、好理解的 C++ 实现**。
我会先给代码，再**逐行带你理解为什么这样写**。

------

## 一、完整 C++ 代码（一次交易，最大利润）

```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main()
{
    int N;
    cin >> N;

    vector<int> prices(N);
    for (int i = 0; i < N; i++)
    {
        cin >> prices[i];
    }

    // 记录历史最低买入价
    int minPrice = prices[0];

    // 记录最大利润（允许为负）
    int maxProfit = prices[1] - prices[0];

    for (int i = 1; i < N; i++)
    {
        // 如果今天卖出，能获得的利润
        int profit = prices[i] - minPrice;

        // 更新最大利润
        if (profit > maxProfit)
        {
            maxProfit = profit;
        }

        // 更新历史最低价格（为以后买入做准备）
        if (prices[i] < minPrice)
        {
            minPrice = prices[i];
        }
    }

    cout << maxProfit << endl;
    return 0;
}
```

------

## 二、逐步理解每一部分在干什么

### 1️⃣ 读入天数和价格

```cpp
int N;
cin >> N;

vector<int> prices(N);
for (int i = 0; i < N; i++)
{
    cin >> prices[i];
}
```

- `N`：有多少天
- `prices[i]`：第 `i` 天的股票价格

------

### 2️⃣ 为什么要记录 `minPrice`？

```cpp
int minPrice = prices[0];
```

含义是：

> **到目前为止，最便宜的买入价格是多少**

你以后每天都在问：

> “如果我今天卖，之前最便宜是哪一天买？”

------

### 3️⃣ 为什么 `maxProfit` 要这样初始化？

```cpp
int maxProfit = prices[1] - prices[0];
```

原因很关键 ⚠️：

- 题目允许 **利润为负**
- 所以不能一开始设为 `0`
- 必须至少执行一次合法交易（第 0 天买，第 1 天卖）

------

### 4️⃣ 核心循环逻辑（整道题的灵魂）

```cpp
for (int i = 1; i < N; i++)
{
    int profit = prices[i] - minPrice;

    if (profit > maxProfit)
    {
        maxProfit = profit;
    }

    if (prices[i] < minPrice)
    {
        minPrice = prices[i];
    }
}
```

每天做三件事：

#### ✅ ① 假设今天卖出

```cpp
profit = 今天价格 - 历史最低买入价
```

#### ✅ ② 看是不是目前最赚钱的一次

```cpp
更新 maxProfit
```

#### ✅ ③ 看今天是不是更适合买入

```cpp
更新 minPrice
```

⚠️ 顺序非常重要：

- **先算利润**
- 再更新最低价
  否则会出现 “当天买当天卖” 的错误情况

------

## 三、用样例走一遍程序

输入：

```
2 5 6 1 4 3 1 3
```

程序内部的思路是：

| 天   | 价格 | minPrice | 当天卖出利润 | maxProfit |
| ---- | ---- | -------- | ------------ | --------- |
| 0    | 2    | 2        | —            | —         |
| 1    | 5    | 2        | 3            | 3         |
| 2    | 6    | 2        | 4            | 4         |
| 3    | 1    | 1        | -1           | 4         |
| 4    | 4    | 1        | 3            | 4         |
| 7    | 3    | 1        | 2            | 4         |

最终输出：

```
4
```

------

## 四、这道题的算法等级

- 时间复杂度：**O(N)**
- 空间复杂度：**O(1)**
- 属于：**经典一次遍历最优解**
- 常见于：面试 / 算法竞赛 / LeetCode

------

如果你愿意，下一步我可以：

- ❓ 带你写 **暴力 O(N²)** 版本对比
- ❓ 改成 **多次交易**
- ❓ 改成 **最多 K 次交易**
- ❓ 用 **动态规划视角**重新解释这道题

你想继续哪一个？





这个问题问得**非常好，而且已经到了“算法思维层面”** 👍
我们不只是会写题，而是要搞清楚：**为什么会想到动态规划（DP）**。

我会按下面 4 个层次，**一步一步把“DP 的本质”讲透**，并且用你这道股票题做对照。

------

# 一、先说结论（你先记住）

👉 **这道题“可以用动态规划”，但你写的最优解看起来不像 DP，是因为它是「状态压缩后的 DP」**。

换句话说：

> 你已经在用 DP 了，只是你没意识到。

------

# 二、动态规划的本质到底是什么？

### ❗一句话定义（非常重要）

> **动态规划 = 把一个问题拆成“有状态、有转移”的子问题，并把中间结果保存下来反复利用**

拆成 4 个关键词：

| 关键词     | 含义                             |
| ---------- | -------------------------------- |
| 状态       | 描述“当前处在什么情况”           |
| 转移       | 当前状态如何由之前状态得到       |
| 最优子结构 | 大问题的最优解来自子问题的最优解 |
| 记忆       | 不重复算已经算过的状态           |

------

# 三、什么时候“该想到”动态规划？

你在读题时，如果发现 **至少两个** 特征，就要警觉了：

### 🚨 动态规划典型信号

1️⃣ **“最大 / 最小 / 最优”**
2️⃣ **过程是一步一步推进的（时间、位置、天数、金额）**
3️⃣ **当前决策依赖于过去的结果**
4️⃣ **暴力会有大量重复计算**

👉 你的题目里有几个？

✔ 最大利润
✔ 天数推进
✔ 今天卖是否赚钱取决于“之前最低价”

**三个全中** —— 这就是 DP 信号灯 🚦

------

# 四、这道股票题，DP 是怎么“藏”在里面的？

我们从 **最原始 DP 思维** 开始，不直接看最终代码。

------

## 1️⃣ 定义“状态”（这是 DP 的第一步）

问自己一句话：

> “到第 i 天为止，我掌握哪些信息？”

### 最原始的 DP 状态定义是：

```text
dp[i] = 第 i 天卖出时，能获得的最大利润
```

------

## 2️⃣ 写出状态转移方程（这是 DP 的灵魂）

如果我第 `i` 天卖出：

- 我必须在 `0 ~ i-1` 天中的某一天买入
- 所以利润是：

```text
dp[i] = prices[i] - min(prices[0..i-1])
```

⚠️ 关键点来了：

> **dp[i] 依赖的是“之前最小价格”这个状态**

------

## 3️⃣ “历史最低价”其实是一个 DP 状态

我们再定义一个状态：

```text
minPrice[i] = 前 i 天中的最低股票价格
```

它的转移是：

```text
minPrice[i] = min(minPrice[i-1], prices[i])
```

是不是很眼熟？

这就是：

```cpp
minPrice = min(minPrice, prices[i]);
```

------

## 4️⃣ 整个 DP 结构现在完整了

| 状态      | 含义                 |
| --------- | -------------------- |
| minPrice  | 之前的最低买入价     |
| maxProfit | 到当前为止的最大利润 |

状态转移：

```text
maxProfit = max(maxProfit, prices[i] - minPrice)
minPrice  = min(minPrice, prices[i])
```

👉 **这就是一个完整的 DP，只不过：**

- 没用数组
- 用两个变量把状态“压缩”了

------

# 五、为什么你感觉不到“二维 DP 表”？

因为 **DP ≠ 二维数组** ❌
那只是最“新手友好”的写法。

### DP 的三种形态

| 形式        | 举例                 |
| ----------- | -------------------- |
| 显式 DP 表  | 01 背包、LCS         |
| 一维 DP     | 爬楼梯               |
| 状态压缩 DP | 股票问题、最大子数组 |

你这题属于：

> **状态压缩 DP（空间优化后的 DP）**

------

# 六、用“人脑决策”来理解 DP（非常重要）

你每天在做的其实是：

> “到今天为止，我最好的买入点是哪天？”
> “如果今天卖，是不是比之前更赚？”

这两句就是 **DP 的状态 + 转移**。

------

# 七、那为什么不用 DP 也能想出来？

因为这题是：

> **DP 的“退化形态”**

状态极少、转移极简单
所以你可以直接写成：

```cpp
minPrice
maxProfit
```

但它 **本质仍然是 DP**

------

# 八、总结（这部分你可以背下来）

### 1️⃣ 动态规划的本质

> **用状态描述过程，用转移描述决策，用记忆避免重复**

------

### 2️⃣ 这道题 DP 体现在哪？

- `minPrice`：历史状态
- `maxProfit`：最优解状态
- 每一天：一次状态转移

------

### 3️⃣ 什么时候该想到 DP？

👉 **看到“最优 + 过程 + 依赖过去”**

------

如果你愿意，下一步我可以：

- 用 **二维 DP 写一遍股票题（非常震撼）**
- 对比 **DP vs 贪心，为什么这题两者等价**
- 教你 **读题 → 判断是不是 DP 的通用模板**
- 用你之前做过的 **01 背包 / 最长公共子串** 串成一个 DP 体系

你选一个，我继续带你“真正入门 DP”。





太好了，这一步你已经**真正进入动态规划核心区了**🔥
我们现在要做的不是“换一种写法”，而是**把隐藏的 DP 状态完整地摊开**。

我会按 **「DP 建模 → 转移 → 初始化 → 完整代码 → 对照压缩版」** 来讲。

------

# 一、先明确：这道题的「标准 DP 建模」

既然你问的是 **“有 dp 数组的写法”**，那我们就用**最原始、最教科书式的 DP**。

------

## 1️⃣ DP 状态定义（最关键）

我们定义一个一维 DP 数组：

```text
dp[i] = 在第 i 天卖出股票时，能获得的最大利润
```

⚠️ 注意：

- **dp[i] 必须卖出**
- 所以 dp[i] 可能是负数
- 最终答案是 `dp[i]` 中的最大值

------

## 2️⃣ 状态转移方程（DP 灵魂）

如果我在第 `i` 天卖出：

- 我只能在第 `0 ~ i-1` 天中某一天买入
- 所以：

```text
dp[i] = prices[i] - min(prices[0...i-1])
```

------

## 3️⃣ 辅助 DP 状态（历史最低价）

为了避免每次都遍历 `0 ~ i-1`，我们引入一个“辅助 DP 状态”：

```text
minPrice[i] = 前 i 天中，最低的股票价格
```

转移方程：

```text
minPrice[i] = min(minPrice[i-1], prices[i])
```

------

# 二、完整 DP 数组写法（清晰版）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    int N;
    cin >> N;

    vector<int> prices(N);
    for (int i = 0; i < N; i++)
    {
        cin >> prices[i];
    }

    // dp[i]：第 i 天卖出时的最大利润
    vector<int> dp(N);

    // minPrice[i]：前 i 天的最低价格
    vector<int> minPrice(N);

    // 初始化
    minPrice[0] = prices[0];
    dp[0] = 0;   // 第 0 天无法卖出，记为 0（不参与比较）

    int ans = INT_MIN;

    for (int i = 1; i < N; i++)
    {
        // 更新历史最低价
        minPrice[i] = min(minPrice[i - 1], prices[i]);

        // 第 i 天卖出能获得的利润
        dp[i] = prices[i] - minPrice[i - 1];

        // 更新答案
        ans = max(ans, dp[i]);
    }

    cout << ans << endl;
    return 0;
}
```

------

# 三、为什么这里一定要用 `minPrice[i-1]`？

```cpp
dp[i] = prices[i] - minPrice[i - 1];
```

⚠️ 这是一个**非常容易出错但非常关键的点**：

- `minPrice[i]` 可能是 **今天的价格**
- 那就变成了 **“当天买，当天卖”**
- 这是不允许的

所以：

> **卖出的最低买入价，必须来自「之前的天数」**

------

# 四、用样例完整跑一遍 DP 表

输入：

```
2 5 6 1 4 3 1 3
```

| 天 i | price | minPrice[i] | dp[i] |
| ---- | ----- | ----------- | ----- |
| 0    | 2     | 2           | —     |
| 1    | 5     | 2           | 3     |
| 2    | 6     | 2           | 4     |
| 3    | 1     | 1           | -1    |
| 4    | 4     | 1           | 3     |
| 5    | 3     | 1           | 2     |
| 6    | 1     | 1           | 0     |
| 7    | 3     | 1           | 2     |

最大值 = **4**

------

# 五、这和你之前的「两变量写法」是什么关系？

| DP 数组版   | 状态压缩版           |
| ----------- | -------------------- |
| minPrice[i] | minPrice             |
| dp[i]       | prices[i] - minPrice |
| ans         | maxProfit            |

👉 **状态完全一致，只是存不存数组的问题**

------

# 六、进阶视角（重要）

其实股票问题的“终极 DP”状态是：

```text
dp[i][0]：第 i 天不持股的最大利润
dp[i][1]：第 i 天持股的最大利润
```

而你这道题是它的 **最简特例（只允许一次交易）**。

------

# 七、你现在真正掌握了什么？

✔ 会写 **显式 DP 数组**
✔ 能区分 **状态定义是否合理**
✔ 明白 **状态压缩不是魔法，是优化**

------

如果你愿意，下一步我可以：

- 把这题 **改成 dp[i][2] 的“正统股票 DP”**
- 对比 **一次交易 vs 无限交易**
- 带你写 **LeetCode 股票系列通解模板**
- 或把这道题和你做过的 **01 背包 / LCS** 串起来

你选一个，我继续带你深入 🚀





非常好，这一步你是在**训练“顺着代码走题意”的能力**，这是算法真正内化的关键 👍
下面我会 **完全结合题目 + 样例输入**，像“程序在你眼前一步步跑一样”，**逐行、逐变量、逐天解释**。

------

# 一、先给出我们要跑的【题目 + 样例】

### 题目核心

- 股票每天一个价格
- **只能交易一次（一次买 + 一次卖）**
- **先买后卖**
- 求最大利润（可以为负）

------

### 样例输入（我们用它完整跑一遍）

```
N = 8
prices = [2, 5, 6, 1, 4, 3, 1, 3]
```

------

# 二、代码整体在干什么（一句话版）

> **从第 1 天开始，假设“今天卖出”，用“之前最低价买入”，算利润，并不断更新最大利润**

------

# 三、逐行 + 逐状态执行过程（非常详细）

------

## 【第一步】读入输入

```cpp
int N;
cin >> N;
```

- 输入 `8`

- 此时：

  ```
  N = 8
  ```

------

```cpp
vector<int> prices(N);
for (int i = 0; i < N; i++)
{
    cin >> prices[i];
}
```

读入 8 个价格：

```
prices = [2, 5, 6, 1, 4, 3, 1, 3]
```

含义是：

| 天数 i | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格   | 2    | 5    | 6    | 1    | 4    | 3    | 1    | 3    |

------

## 【第二步】创建 DP 数组和辅助数组

```cpp
vector<int> dp(N);
vector<int> minPrice(N);
```

此时（还没赋值，逻辑上可以认为是未定义）：

```
dp        = [?, ?, ?, ?, ?, ?, ?, ?]
minPrice = [?, ?, ?, ?, ?, ?, ?, ?]
```

------

## 【第三步】初始化（非常重要）

```cpp
minPrice[0] = prices[0];
dp[0] = 0;
```

### 含义解释

#### `minPrice[0] = prices[0]`

- 到 **第 0 天为止**
- 唯一出现的价格就是 `2`
- 所以历史最低价一定是 `2`

```
minPrice = [2, ?, ?, ?, ?, ?, ?, ?]
```

------

#### `dp[0] = 0`

- 第 0 天 **不能卖**
- 因为你之前没买过
- 所以这个值只是“占位”，不参与最终比较

```
dp = [0, ?, ?, ?, ?, ?, ?, ?]
```

------

```cpp
int ans = INT_MIN;
```

- `ans` 用来保存 **最终最大利润**
- 初始化为极小值，是因为：
  - 题目允许 **利润为负**
  - 不能初始化为 `0`

```
ans = -∞
```

------

## 【第四步】进入核心循环（从第 1 天开始）

```cpp
for (int i = 1; i < N; i++)
```

⚠️ 为什么从 `i = 1`？

- 因为卖出必须 **有之前的买入**
- 第 0 天不能卖

------

# 五、逐天完整执行过程（重点部分）

------

## 🔹 第 1 天（i = 1）

### 当前价格

```
prices[1] = 5
```

------

### ① 更新历史最低价

```cpp
minPrice[1] = min(minPrice[0], prices[1]);
```

计算：

```
min(2, 5) = 2
minPrice = [2, 2, ?, ?, ?, ?, ?, ?]
```

------

### ② 假设今天卖出，计算利润

```cpp
dp[1] = prices[1] - minPrice[0];
```

> ⚠️ 注意：**必须用 `minPrice[i-1]`**

```
dp[1] = 5 - 2 = 3
dp = [0, 3, ?, ?, ?, ?, ?, ?]
```

含义：

> 第 0 天 2 元买入，第 1 天 5 元卖出，赚 3

------

### ③ 更新最大利润

```cpp
ans = max(ans, dp[1]);
ans = max(-∞, 3) = 3
```

------

## 🔹 第 2 天（i = 2）

### 当前价格

```
prices[2] = 6
```

------

### ① 更新最低价

```
minPrice[2] = min(2, 6) = 2
minPrice = [2, 2, 2, ?, ?, ?, ?, ?]
```

------

### ② 今天卖出的利润

```
dp[2] = 6 - 2 = 4
dp = [0, 3, 4, ?, ?, ?, ?, ?]
```

------

### ③ 更新最大利润

```
ans = max(3, 4) = 4
```

------

## 🔹 第 3 天（i = 3）

### 当前价格

```
prices[3] = 1
```

------

### ① 更新最低价

```
minPrice[3] = min(2, 1) = 1
minPrice = [2, 2, 2, 1, ?, ?, ?, ?]
```

------

### ② 今天卖出的利润

```
dp[3] = 1 - 2 = -1
dp = [0, 3, 4, -1, ?, ?, ?, ?]
```

含义：

> 如果之前最低价 2 买，今天 1 卖，是亏钱的

------

### ③ 更新最大利润

```
ans = max(4, -1) = 4
```

------

## 🔹 第 4 天（i = 4）

```
prices[4] = 4
```

- minPrice[4] = min(1,4) = 1
- dp[4] = 4 - 1 = 3
- ans = max(4,3) = 4

------

## 🔹 第 5 天（i = 5）

```
prices[5] = 3
```

- minPrice[5] = 1
- dp[5] = 3 - 1 = 2
- ans = 4

------

## 🔹 第 6 天（i = 6）

```
prices[6] = 1
```

- minPrice[6] = 1
- dp[6] = 1 - 1 = 0
- ans = 4

------

## 🔹 第 7 天（i = 7）

```
prices[7] = 3
```

- minPrice[7] = 1
- dp[7] = 3 - 1 = 2
- ans = 4

------

# 六、最终 DP 表全貌

| 天 i | price | minPrice[i] | dp[i] |
| ---- | ----- | ----------- | ----- |
| 0    | 2     | 2           | 0     |
| 1    | 5     | 2           | 3     |
| 2    | 6     | 2           | 4     |
| 3    | 1     | 1           | -1    |
| 4    | 4     | 1           | 3     |
| 5    | 3     | 1           | 2     |
| 6    | 1     | 1           | 0     |
| 7    | 3     | 1           | 2     |

------

## 最终输出

```cpp
cout << ans << endl;
```

输出：

```
4
```

------

# 七、用一句话总结这个执行过程（非常重要）

> **每天都假设“今天卖出”，用“之前的最低价格买入”，算一次利润，并不断维护历史最优解**

------

如果你愿意，下一步我可以：

- 把这段代码 **改成二维 dp[i][0/1] 的标准股票 DP**
- 让你对比：**“一次交易” vs “多次交易”**
- 或让你自己来“手推一遍”，我只在你卡住时提示

你想继续哪一步？