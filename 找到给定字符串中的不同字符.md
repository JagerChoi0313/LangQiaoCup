找到给定字符串中的不同字符

### 题目描述

在不考虑字符排列的条件下，对于相差只有一个字符的两个字符串，实现一个算法来识别相差的那个字符。要求如下：

1. 当传入的字符串为 `aad` 和 `ad` 时，结果为 `a`。
2. 当传入的字符串为 `aaabccdd` 和 `abdcacade` 时，结果为 `e`。

### 输入描述

输入两行字符串，长度均不超过 100。

### 输出描述:

输出一行，为相差的那个字符。

### 输入输出样例

#### 示例

> 输入

```txt
aad
ad
```

> 输出

```txt
a
```





这是一个**经典的“找两个字符串中多出来的那个字符”**问题，题目说明 **不考虑字符排列**，也就是说顺序无关，只看字符出现次数。

------

## 解题思路（推荐）

### 思路一：字符计数（最直观、最稳妥）

1. 用一个数组统计第一个字符串中每个字符出现的次数
2. 再用第二个字符串的字符去抵消计数
3. 最后计数不为 0 的字符，就是多出来的那个

字符范围是 ASCII（或小写字母也行），字符串长度 ≤ 100，完全够用。

------

## 示例分析

### 示例 1

```
aad
ad
```

计数结果：

```
a: 2 - 1 = 1  → 多出来的字符是 a
```

### 示例 2

```
aaabccdd
abdcacade
```

统计后：

```
e 出现 1 次 → 多出来的字符是 e
```

------

## C++ 实现代码（推荐）

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;

    int cnt[256] = {0}; // ASCII 字符计数

    // 统计第一个字符串
    for (char c : s1) {
        cnt[c]++;
    }

    // 抵消第二个字符串
    for (char c : s2) {
        cnt[c]--;
    }

    // 找出计数不为 0 的字符
    for (int i = 0; i < 256; i++) {
        if (cnt[i] != 0) {
            cout << (char)i << endl;
            break;
        }
    }

    return 0;
}
```

------

## 思路二（进阶）：异或 XOR（更简洁）

> 利用：
> `a ^ a = 0`
> `0 ^ b = b`

把两个字符串所有字符全部异或一遍，最后剩下的就是多出来的字符。

### C++ XOR 解法

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;

    char result = 0;

    for (char c : s1) result ^= c;
    for (char c : s2) result ^= c;

    cout << result << endl;
    return 0;
}
```

------

## 两种方法对比

| 方法   | 优点               | 适合          |
| ------ | ------------------ | ------------- |
| 计数法 | 思路清晰，容易理解 | 面试 / 初学者 |
| XOR    | 代码极简，效率高   | 熟练后使用    |

------

如果你是**做笔试 / 面试**，我建议你**先写计数法，再提一句 XOR 优化**，加分 👍
需要我帮你写 **OJ 风格版本** 或 **解释 XOR 原理** 也可以继续问。







很好，这一段**正是“从结果里找答案”的关键**，我们就**只拆这一小段**，把它掰开揉碎来理解 👌

------

## 一、先把代码单独拎出来

```cpp
for (int i = 0; i < 256; i++) {
    if (cnt[i] != 0) {
        cout << (char)i << endl;
        break;
    }
}
```

------

## 二、这段代码在“整体算法”中是干什么的？

在前面步骤中，我们已经做完了：

- 第一个字符串：`cnt[字符]++`
- 第二个字符串：`cnt[字符]--`

**此时数组的状态是：**

> ✔ 所有相同的字符都被抵消成 `0`
> ❗ 只有“多出来的那个字符”的 `cnt` 不为 `0`

👉 **这段代码的目的：**

> 在 `cnt` 数组中找到那个 **不等于 0 的位置**

------

## 三、逐行、逐字理解

------

### ① `for (int i = 0; i < 256; i++)`

#### 这句是什么意思？

- `i`：表示 **ASCII 编码**
- 从 `0` 到 `255`
- 把 `cnt` 数组 **从头到尾检查一遍**

可以理解为：

> “我现在一个一个字符去看：
> ASCII 为 0 的字符有没有问题？
> ASCII 为 1 的字符有没有问题？
> ……
> ASCII 为 255 的字符有没有问题？”

------

### ② `if (cnt[i] != 0)`

#### 这句在判断什么？

- `cnt[i]`：字符 `(char)i` 的最终出现次数差

- 正常字符：

  ```
  出现次数 +1 和 -1 抵消 → cnt[i] == 0
  ```

- **异常字符（多出来的那个）**：

  ```
  cnt[i] == 1 或 cnt[i] == -1
  ```

👉 所以这句等价于：

> “如果这个字符在两个字符串中出现次数不一样”

------

### ③ `cout << (char)i << endl;`

#### 关键点：为什么要 `(char)i`？

- `i` 是一个 **整数**（ASCII 编码）
- `(char)i` 是把这个编码 **强制转换成字符**

举例：

| i    | (char)i |
| ---- | ------- |
| 97   | 'a'     |
| 98   | 'b'     |
| 101  | 'e'     |

所以：

```cpp
cout << (char)i;
```

就是：

> “把 ASCII 编码为 i 的字符输出出来”

------

### ④ `break;`

#### 这句为什么必须有？

- 题目保证：**只相差一个字符**
- 也就是说：
  👉 `cnt[i] != 0` **只会出现一次**

`break` 的作用：

> 找到答案后，**立刻结束循环**，不再浪费时间

如果没有 `break`：

- 理论上还能继续扫
- 但逻辑上没必要，也不严谨

------

## 四、结合真实执行过程（用示例）

### 示例输入

```
aaabccdd
abdcacade
```

### 抵消后 cnt 中关键部分

```
cnt['a'] = 0
cnt['b'] = 0
cnt['c'] = 0
cnt['d'] = 0
cnt['e'] = -1
```

------

### for 循环执行轨迹

| i    | 字符     | cnt[i] | 判断   |
| ---- | -------- | ------ | ------ |
| 0~96 | 控制字符 | 0      | 跳过   |
| 97   | 'a'      | 0      | 跳过   |
| 98   | 'b'      | 0      | 跳过   |
| 99   | 'c'      | 0      | 跳过   |
| 100  | 'd'      | 0      | 跳过   |
| 101  | 'e'      | **-1** | ✅ 命中 |

执行：

```cpp
cout << (char)101 << endl; // 输出 e
break;                    // 退出循环
```

------

## 五、这段代码用一句话理解

> **从 ASCII 0 到 255 逐个检查字符，只要发现某个字符在两个字符串中出现次数不同，就把它输出**

------

## 六、常见疑问（你可能马上会问）

### ❓ 为什么不直接遍历字符串？

因为：

- 我们要找的是 **“抵消后的结果”**
- 不知道哪个字符多
- 最可靠方式：**扫完整个计数表**

------

### ❓ cnt[i] 可能是正数还是负数？

两种都可能：

| 情况           | cnt   |
| -------------- | ----- |
| 第一个字符串多 | `> 0` |
| 第二个字符串多 | `< 0` |

但题目只关心 **是哪一个字符**

------

## 七、你已经掌握了什么（非常重要）

现在你已经真正理解了：

- 数组下标 ≠ 普通数字
- 它可以 **代表字符的 ASCII**
- `(char)i` 是 **“数字 → 字符” 的桥梁**
- `break` 是 **逻辑正确性的保障**

------

如果你愿意，下一步我可以：

- 把这段代码改成 **调试器视角逐步执行**
- 或画一张 **cnt 数组变化示意图**
- 或帮你写一版 **完全不用 ASCII 的写法**（比如 map）

你选哪个？