求解台阶问题

### 题目描述

现一个算法求解台阶问题。介绍如下：

- 对于高度为 n*n* 的台阶，从下往上走，每一步的阶数为 1，2，3 中的一个。问要走到顶部一共有多少种走法。

### 输入描述

输入一个数字 N (1≤N≤35)*N* (1≤*N*≤35)，表示台阶的高度。

### 输出描述

输出一行，为走法总数。

### 输入输出样例

#### 示例

> 输入

```txt
4
```

> 输出

```txt
 7
```





这道**台阶问题**你其实已经写出了一份「**看起来像对，但本质不对**」的代码，这也是很多人第一次做这题时必踩的坑 👍
我们一步一步把**问题本质、正确 DP 建模、以及你这份代码到底哪里“想偏了”**讲清楚。

------

## 一、先明确问题本质（非常关键）

> 台阶高度为 `N`
> 每一步可以走 `1 / 2 / 3` 级
> **问一共有多少种走法**

⚠️ **“走法”是否区分顺序？**
答案是：**区分顺序！**

例如 `N = 4`：

- 1 + 3
- 3 + 1

这是 **两种不同走法**

所以这是一个：

> **顺序敏感（排列型）的计数问题**

------

## 二、正确的 DP 思维（台阶问题的经典模型）

### 1️⃣ 状态定义（这是灵魂）

> `dp[i]`：走到 **第 i 级台阶** 的走法总数

------

### 2️⃣ 状态转移怎么想出来的？

要到第 `i` 级台阶，**最后一步**只能是：

- 从 `i-1` 走 1 级
- 从 `i-2` 走 2 级
- 从 `i-3` 走 3 级

所以：

```
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

这一步是**台阶问题的核心公式**

------

### 3️⃣ 初始化

- `dp[0] = 1`
  👉 表示“什么都不走”是一种合法方式（非常重要）
- 其它默认 0

------

### 4️⃣ 边界检查

当 `i-2 < 0` 或 `i-3 < 0` 时，不加即可

------

## 三、标准正确代码（推荐你牢牢记住）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int N;
    cin >> N;

    vector<long long> dp(N + 1, 0);
    dp[0] = 1;

    for (int i = 1; i <= N; i++)
    {
        if (i - 1 >= 0) dp[i] += dp[i - 1];
        if (i - 2 >= 0) dp[i] += dp[i - 2];
        if (i - 3 >= 0) dp[i] += dp[i - 3];
    }

    cout << dp[N];
    return 0;
}
```

------

### 🔍 用 `N = 4` 验证

```
dp[0] = 1
dp[1] = 1
dp[2] = 2
dp[3] = 4
dp[4] = 7
```

输出 **7** ✅

------

## 四、那你写的代码「错在哪」？（这是重点）

你的代码是：

```cpp
for(int i=1;i<=3;i++)
{
    for(int j=platform[i];j<=N;j++)
    {
        dp[j] += dp[j-platform[i]];
    }
}
```

### ❌ 这是什么模型？

这是一个：

> **完全背包（组合数，不区分顺序）**

它计算的是：

- 1、2、3 作为“物品”
- 目标凑出 N
- **1+3 和 3+1 被当成同一种**

👉 这和台阶问题 **本质不符**

------

### 🚨 核心区别一句话版

| 问题     | 是否区分顺序 | DP 循环顺序        |
| -------- | ------------ | ------------------ |
| 台阶问题 | ✅ 区分       | **先台阶，再步数** |
| 完全背包 | ❌ 不区分     | **先物品，再容量** |

------

## 五、为什么台阶问题不能用“背包写法”？

因为你人在走台阶时：

> **每一步的顺序就是路径本身**

而背包问题默认认为：

> 1 → 3 和 3 → 1 没区别

这在台阶问题中是**致命错误**

------

## 六、帮你形成一个“条件反射判断”

以后看到问题，先问自己一句话：

> **顺序重不重要？**

- ✅ 重要 → `dp[i] += dp[i - step]`
- ❌ 不重要 → 背包套路

------

## 七、一句话总结（给你压缩记忆用）

> **台阶问题 = 有顺序的完全递推**
> **公式永远是：`dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`**

如果你愿意，下一步我可以帮你：

- 把它和 **斐波那契**、**完全背包**做一张对照表
- 或者用 **递归 → 记忆化 → DP** 的演化过程再推一遍

你卡住的点，其实已经非常接近本质了 👍





好，这次我们**不讲套路、不跳步**，就把这份**“正确台阶代码”当成一段白话故事**，一行一行拆开来理解：
👉 **为什么要这样写、每一行在“想什么”**

我先把代码贴出来，然后逐行解释。

------

## 一、完整代码（你正在问的这份）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int N;
    cin >> N;

    vector<long long> dp(N + 1, 0);
    dp[0] = 1;

    for (int i = 1; i <= N; i++)
    {
        if (i - 1 >= 0) dp[i] += dp[i - 1];
        if (i - 2 >= 0) dp[i] += dp[i - 2];
        if (i - 3 >= 0) dp[i] += dp[i - 3];
    }

    cout << dp[N];
    return 0;
}
```

------

## 二、从「人走台阶」的角度开始想（非常重要）

先记住一句话：

> **dp[i] 不是数组，是一句话：
> dp[i] = 走到第 i 级台阶的方法总数**

代码的每一行，都是在服务这句话。

------

## 三、逐行解释（一句代码一句“人话”）

------

### ① 读入 N

```cpp
int N;
cin >> N;
```

👉 台阶一共有 **N 级**
👉 我们的目标是：**走到第 N 级**

------

### ② 创建 dp 数组

```cpp
vector<long long> dp(N + 1, 0);
```

**这行非常关键**

- `dp[i]`：走到第 `i` 级台阶的走法数
- 为什么是 `N + 1`？
  - 因为我们要用 `dp[0] ~ dp[N]`
- 为什么初始值是 `0`？
  - 先假设“什么路都没走出来”，后面再慢慢加

👉 此时脑子里可以想象一排台阶：

```
dp[0] dp[1] dp[2] ... dp[N]
```

------

### ③ dp[0] = 1（最容易被忽略的一行）

```cpp
dp[0] = 1;
```

🔥 **这一行是整个 DP 成立的“地基”**

含义是：

> 站在第 0 级台阶（起点）
> 👉 有 **1 种方式**（什么都不做）

为什么不是 0？

因为后面会有：

```cpp
dp[1] += dp[0];
```

如果 `dp[0] = 0`，那所有结果都会变成 0。

📌 **dp[0] = 1 的本质**

> “空路径”是一种合法起点

------

### ④ 主循环：从低到高算台阶

```cpp
for (int i = 1; i <= N; i++)
```

👉 意思是：

> 我们按顺序计算：
>
> - 先算能不能到 1 级
> - 再算 2 级
> - 再算 3 级
> - ……
> - 一直算到 N 级

📌 **动态规划的核心思想**：

> 当前状态只依赖「更小的状态」

------

## 四、最核心的三行（灵魂部分）

### ⑤ 从 i-1 走 1 步过来

```cpp
if (i - 1 >= 0)
    dp[i] += dp[i - 1];
```

人话翻译：

> 如果我现在在第 `i` 级
> 那我**最后一步**可以是：
>
> - 从 `i-1` 级走 1 步上来
>   👉 那有多少种？
>   👉 **dp[i-1] 种**

所以：

```
dp[i] += dp[i-1]
```

------

### ⑥ 从 i-2 走 2 步过来

```cpp
if (i - 2 >= 0)
    dp[i] += dp[i - 2];
```

人话：

> 最后一步也可能是：
>
> - 从 `i-2` 级，一次跨 2 级
>   👉 那就是 `dp[i-2]` 种走法

------

### ⑦ 从 i-3 走 3 步过来

```cpp
if (i - 3 >= 0)
    dp[i] += dp[i - 3];
```

人话：

> 最后一步还可能：
>
> - 从 `i-3` 级，一次跨 3 级

------

### 🔑 把三步合起来，就是：

```cpp
dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
```

这不是“硬记公式”，而是：

> **枚举“最后一步”的所有可能**

------

## 五、用 N = 4 跑一遍（你会彻底通）

### 初始：

```
dp[0] = 1
dp[1..4] = 0
```

------

### i = 1

- dp[1] += dp[0] → 1

```
dp[1] = 1
```

------

### i = 2

- dp[2] += dp[1] → 1
- dp[2] += dp[0] → 1

```
dp[2] = 2
```

------

### i = 3

- dp[3] += dp[2] → 2
- dp[3] += dp[1] → 1
- dp[3] += dp[0] → 1

```
dp[3] = 4
```

------

### i = 4

- dp[4] += dp[3] → 4
- dp[4] += dp[2] → 2
- dp[4] += dp[1] → 1

```
dp[4] = 7
```

------

## 六、最后输出答案

```cpp
cout << dp[N];
```

👉 走到第 N 级台阶的走法总数

------

## 七、一句话帮你“刻进脑子里”

> **台阶 DP 的本质：
> “最后一步从哪里来？”**

代码不是在算数组，而是在不断回答：

> “如果我最后一步走 1 / 2 / 3 级，那之前有多少种走法？”

------

如果你愿意，下一步我可以帮你做三件事之一：

1️⃣ 把这段代码改写成 **递归 → 记忆化 → DP**
2️⃣ 和你之前的 **完全背包写法逐行对比**
3️⃣ 推广到「一次最多走 k 级」你自己写公式

你已经站在 **DP 真正入门的门口**了。



这个问题问得**非常到位** 👍
因为你已经不是在问“这题怎么做”，而是在问：

> **我是不是真的理解了台阶 DP 的本质**

答案是：你这一步，已经摸到核心了。

------

## 一、把问题翻译成人话

> 台阶高度为 `N`
> **每一步可以走 `1 ~ N` 级（任意多，只要不超过剩余台阶）**
> 问一共有多少种走法

⚠️ 顺序仍然重要（走法）

------

## 二、先别写代码，先用“最后一步”想

和之前一模一样，只是「选择更多了」。

### 关键一句话（你一定要记住）

> **dp[i] = 所有“能一步走到 i”的情况之和**

------

## 三、重新定义 dp（不变）

> `dp[i]`：走到第 `i` 级台阶的走法数

------

## 四、状态转移（自然推出来）

如果一次最多能走 `N` 级，那么：

- 最后一步可以从
  `i-1, i-2, i-3, ... , 0`

所以：

```
dp[i] = dp[i-1] + dp[i-2] + ... + dp[0]
```

------

## 五、初始化（仍然关键）

```
dp[0] = 1
```

含义不变：**空路径是一种走法**

------

## 六、直接写代码（最直观版）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    int N;
    cin >> N;

    vector<long long> dp(N + 1, 0);
    dp[0] = 1;

    for (int i = 1; i <= N; i++)
    {
        for (int step = 1; step <= i; step++)
        {
            dp[i] += dp[i - step];
        }
    }

    cout << dp[N];
    return 0;
}
```

------

## 七、你会发现一个“吓人”的结果 😄

我们算几个小值：

| N    | dp[N] |
| ---- | ----- |
| 0    | 1     |
| 1    | 1     |
| 2    | 2     |
| 3    | 4     |
| 4    | 8     |
| 5    | 16    |

🔥 规律出现了：

```
dp[N] = 2^(N-1)
```

------

## 八、为什么会变成 2^(N-1)？

直觉版理解：

- 从 1 到 N 的过程中
- 每个“台阶之间的缝”
- 你都有：
  - 不停
  - 停一下（作为一步的结束）

👉 **本质是在数“切分方案”**

这其实等价于：

> 把整数 N 分成若干正整数（顺序相关）

------

## 九、你现在可以总结出一个“万能台阶公式”了

### 如果一次最多走 k 级：

```
dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-k]
```

（越界的不加）

------

## 十、把你今天真正学到的东西点出来

你已经掌握了三件**非常硬核**的能力：

1️⃣ **状态定义不会乱**（dp[i] 是“走到哪”）
2️⃣ **转移靠“最后一步”枚举，而不是背公式**
3️⃣ 能判断：

> 这是「顺序相关」问题，不是背包组合问题

------

### 最后送你一句“DP 内功心法”

> **动态规划不是在推数组
> 是在不断回答：
> “我最后一步是怎么走的？”**

如果你愿意，下一步我可以带你：

- 把它和 **整数拆分 / 完全背包**彻底区分
- 或教你 **O(N) → O(1)** 的优化思路
- 或让你自己写「一次最多走 k 级」的模板代码，我来帮你改

你现在问的问题，已经是**进阶问题**了。



这个问题**问得非常准**，而且你已经踩在
👉 **「台阶 DP」 vs 「完全背包（硬币）」的分水岭**上了。

我们不绕弯子，**直接抓“本质差异”**，而不是停留在代码长得像不像。

------

## 一、先给结论（一句话版）

> **台阶问题：数的是「顺序不同也算不同」**
> **完全背包硬币问题：数的是「顺序不同算同一种」**

虽然代码形式看起来都在 `dp[i] += dp[i - step]`，
但**循环顺序 + dp 的语义完全不同**。

------

## 二、把你这段代码“翻译成人话”

你的代码是：

```cpp
for (int i = 1; i <= N; i++)
{
    for (int step = 1; step <= i; step++)
    {
        dp[i] += dp[i - step];
    }
}
```

### dp 的含义是：

> `dp[i]` = **走到第 i 级台阶的走法数**

### 每一轮在干嘛？

当你算 `dp[i]` 时：

- 枚举 **最后一步走了多少级**
- `step = 1 ~ i`
- 每一种 `step` 都代表一种「最后动作」

👉 **这是在数「路径」**

------

## 三、再看“完全背包硬币问题”的经典写法

比如：硬币 `{1, 2, 3}`，凑钱 `N`

```cpp
for (int coin : coins)
{
    for (int j = coin; j <= N; j++)
    {
        dp[j] += dp[j - coin];
    }
}
```

### dp 的含义是：

> `dp[j]` = **用当前及之前的硬币，凑出金额 j 的方案数**

👉 注意：
**并不是“走到 j 的路径”**

------

## 四、真正的分水岭：dp 在“数什么”？

| 问题     | dp 在数  | 顺序       |
| -------- | -------- | ---------- |
| 台阶问题 | 行走路径 | 顺序敏感   |
| 完全背包 | 物品组合 | 顺序不敏感 |

------

## 五、用同一个例子，直接“掀桌子对比”

### 目标：`N = 3`

------

### ① 台阶问题（一次可走 1~3 级）

**合法走法：**

```
1+1+1
1+2
2+1
3
```

👉 **4 种**

你的代码算的是这个。

------

### ② 完全背包（硬币 {1,2,3}）

**合法组合：**

```
1+1+1
1+2
3
```

👉 **3 种**

⚠️ `1+2` 和 `2+1` 被认为是同一种

------

## 六、为什么“循环顺序”决定了一切？

### 🔥 台阶问题：**先算目标，再枚举动作**

```cpp
for (i = 1 .. N)      // 我现在站在哪一级
    for (step = 1..) // 我最后一步怎么走
```

👉 每一次转移，都会**保留顺序信息**

------

### 🔥 完全背包：**先固定物品，再扩展容量**

```cpp
for (coin in coins)  // 我用的是哪种硬币
    for (j = coin..) // 凑到多少钱
```

👉 后面的硬币**永远不会“回头重排”**

这一步，直接**抹掉了顺序**

------

## 七、一个“看代码就能判断本质”的口诀

> **外层是“目标” → 顺序相关（排列）**
> **外层是“物品” → 顺序无关（组合）**

你现在看到的两段代码：

- 看起来像
- 本质完全不一样

------

## 八、你现在已经能做的事（很关键）

你已经可以做到：

- 看到一道题
- 不急着写 dp
- 先问一句：

> **“1 + 2 和 2 + 1 算不算一样？”**

这个问题，能直接决定你用哪一套 DP。

------

## 九、最后给你一个“总表”压缩记忆

| 问题类型   | 循环顺序    | dp 含义  |
| ---------- | ----------- | -------- |
| 台阶       | 目标 → 步长 | 走法     |
| 完全背包   | 物品 → 容量 | 组合     |
| 排列型背包 | 容量 → 物品 | 顺序路径 |

------

如果你愿意，下一步我可以直接帮你做一件**非常有用的事**：

👉 **把“台阶问题”改写成「硬币排列型 DP」的统一模板**
这样你以后看到这类题，**3 秒钟就能判断写法**。

你现在的问题，已经是**理解层面的分界线问题**了，而不是“会不会写代码”。