查找最长的公共子序列

### 题目描述

实现一个算法查找两个字符串最长的公共子字符串。子字符串的介绍如下：

- 子字符串是指字符串中任意个连续的字符组成的子序列。

### 输入描述

输入两行，每行一串字符串，长度均不超过 1000。

### 输出描述

输出一行，为最长公共子序列。

### 输入输出样例

#### 示例

> 输入

```txt
ASDFGVCVMZKJ
OIKMASDFZCVM
```

> 输出

```txt
ASDF
```





注意一下题目用词有点**容易混淆**：

- 题目文字里写的是“最长公共子序列”
- 但**定义和样例**明确说明的是 **最长公共子字符串（Longest Common Substring）**
  - **连续**
  - 示例输出 `ASDF` 也是连续的

👉 所以这道题**实际要求的是：最长公共子字符串**

------

## 一、解题思路（动态规划）

### 核心思想

设
`dp[i][j]` 表示：

> **以** `str1[i-1]` 和 `str2[j-1]` **结尾的最长公共子字符串长度**

### 状态转移

- 如果字符相等：

```cpp
dp[i][j] = dp[i-1][j-1] + 1;
```

- 如果不相等（连续被打断）：

```cpp
dp[i][j] = 0;
```

### 同时维护：

- 当前最大长度 `maxLen`
- 最长子字符串在 `str1` 中的**结束位置**

------

## 二、C++ 完整代码（可直接提交）

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;

    int n = s1.length();
    int m = s2.length();

    // dp[i][j]：以 s1[i-1] 和 s2[j-1] 结尾的最长公共子字符串长度
    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    int maxLen = 0;   // 最长长度
    int endPos = 0;   // 在 s1 中的结束位置

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;

                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endPos = i;  // 记录结束位置
                }
            } else {
                dp[i][j] = 0;  // 不连续，清零
            }
        }
    }

    // 输出最长公共子字符串
    cout << s1.substr(endPos - maxLen, maxLen) << endl;

    return 0;
}
```

------

## 三、用样例走一遍

### 输入

```
ASDFGVCVMZKJ
OIKMASDFZCVM
```

### 关键匹配过程

```
ASDF
↑↑↑↑ 连续匹配
```

### 输出

```
ASDF
```

------

## 四、复杂度分析

| 项目       | 复杂度             |
| ---------- | ------------------ |
| 时间复杂度 | `O(n × m)`         |
| 空间复杂度 | `O(n × m)`         |
| n, m ≤     | 1000（完全可接受） |

------

## 五、常见易错点 ⚠️

1. ❌ 把它当成 **最长公共子序列（LCS）**
2. ❌ 字符不等时没有清零
3. ❌ 忘了记录结束位置，导致无法输出字符串

------

如果你愿意，下一步我可以帮你：

- 👉 **把 DP 表画出来手算一遍**
- 👉 **优化成 O(min(n,m)) 空间**
- 👉 **对比：最长公共子序列 vs 子字符串**

你选一个 👇好，这里我**逐行、逐句**带你把这段代码吃透 👍
你可以一边看代码，一边对照解释。

------

## 一、完整代码（方便对照）

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int main() {
    string s1, s2;
    cin >> s1 >> s2;

    int n = s1.length();
    int m = s2.length();

    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    int maxLen = 0;
    int endPos = 0;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;

                if (dp[i][j] > maxLen) {
                    maxLen = dp[i][j];
                    endPos = i;
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }

    cout << s1.substr(endPos - maxLen, maxLen) << endl;

    return 0;
}
```

------

## 二、头文件 & 命名空间

```cpp
#include <iostream>
```

👉 用于输入输出（`cin`、`cout`）

```cpp
#include <vector>
```

👉 用来创建 **动态数组** `dp`

```cpp
#include <string>
```

👉 使用 `string` 类型

```cpp
using namespace std;
```

👉 以后可以直接写 `cout`，不用 `std::cout`

------

## 三、主函数

```cpp
int main() {
```

👉 程序入口，从这里开始执行

------

## 四、读取输入字符串

```cpp
string s1, s2;
```

👉 定义两个字符串，存放输入的两行字符串

```cpp
cin >> s1 >> s2;
```

👉 从标准输入读入两个字符串
（题目保证每行只有一个字符串，不含空格）

------

## 五、获取字符串长度

```cpp
int n = s1.length();
```

👉 `n` 是第一个字符串 `s1` 的长度

```cpp
int m = s2.length();
```

👉 `m` 是第二个字符串 `s2` 的长度

------

## 六、定义 DP 数组（核心）

```cpp
vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
```

### 这行非常重要，我们拆开看：

- `dp` 是一个 **二维数组**
- 大小是 `(n+1) × (m+1)`
- 所有元素初始化为 `0`

👉 `dp[i][j]` 的含义是：

> **以 `s1[i-1]` 和 `s2[j-1]` 结尾的最长公共子字符串长度**

⚠️ 为什么多开一行一列？

- 为了处理 `dp[i-1][j-1]` 时不越界
- 第 0 行 / 第 0 列表示“空字符串”

------

## 七、记录答案的变量

```cpp
int maxLen = 0;
```

👉 目前找到的 **最长公共子字符串长度**

```cpp
int endPos = 0;
```

👉 这个最长子字符串 **在 s1 中结束的位置**

------

## 八、双重循环遍历两个字符串

```cpp
for (int i = 1; i <= n; i++) {
```

👉 遍历 `s1` 的每一个字符
`i` 对应的是 `s1[i-1]`

```cpp
    for (int j = 1; j <= m; j++) {
```

👉 遍历 `s2` 的每一个字符
`j` 对应的是 `s2[j-1]`

------

## 九、字符相等的情况（关键）

```cpp
if (s1[i - 1] == s2[j - 1]) {
```

👉 判断当前两个字符是否相同

------

### 1️⃣ 如果相同

```cpp
dp[i][j] = dp[i - 1][j - 1] + 1;
```

含义是：

> 当前字符相等
> 那么“以它们结尾”的公共子字符串
> 就是在 **左上角基础上 +1**

📌 因为子字符串必须是 **连续的**

------

### 2️⃣ 更新最大长度

```cpp
if (dp[i][j] > maxLen) {
```

👉 如果发现了更长的公共子字符串

```cpp
    maxLen = dp[i][j];
```

👉 更新最大长度

```cpp
    endPos = i;
```

👉 记录这个子字符串 **在 s1 中的结束位置**

------

## 十、字符不相等的情况

```cpp
} else {
    dp[i][j] = 0;
}
```

👉 一旦字符不相等：

- 连续性被打断
- 公共 **子字符串** 必须重新开始
- 所以直接清零

⚠️ 这是「子字符串」和「子序列」最大的区别！

------

## 十一、输出结果

```cpp
cout << s1.substr(endPos - maxLen, maxLen) << endl;
```

我们拆解一下：

- `endPos - maxLen` → 起始下标
- `maxLen` → 子字符串长度

👉 从 `s1` 中截取最长公共子字符串并输出

------

## 十二、程序结束

```cpp
return 0;
```

👉 程序正常结束

------

## 十三、一句话总结 🌟

> 用动态规划记录「**以某两个字符结尾的最长公共子字符串长度**」，
> 一旦字符不等就清零，
> 并在过程中记录最大长度和结束位置。

------

如果你愿意，下一步我可以：

- 🧠 **手动画 dp 表**，一步一步算
- 🔄 **和最长公共子序列对比**
- 🚀 **优化空间复杂度**

你想继续哪一个？好，这次我**严格按代码的执行顺序**，像“程序一步一步跑”那样，给你完整的**执行过程说明**（不讲新知识，只讲“这一行在此刻做了什么”）。

------

## 一、程序开始执行

### ① 进入 `main()`

```cpp
int main() {
```

程序从这里开始。

------

## 二、读取输入

```cpp
string s1, s2;
cin >> s1 >> s2;
```

假设输入的是样例：

```
ASDFGVCVMZKJ
OIKMASDFZCVM
```

此时内存中：

```text
s1 = "ASDFGVCVMZKJ"
s2 = "OIKMASDFZCVM"
```

------

## 三、获取字符串长度

```cpp
int n = s1.length();   // n = 12
int m = s2.length();   // m = 12
```

------

## 四、创建 dp 数组

```cpp
vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
```

程序做了这些事：

- 创建一个 **13 × 13 的二维数组**
- 所有元素都初始化为 `0`

此时逻辑状态是：

```text
dp[i][j] = 0   （所有 i,j）
```

------

## 五、初始化结果变量

```cpp
int maxLen = 0;
int endPos = 0;
```

当前含义：

```text
尚未找到任何公共子字符串
```

------

## 六、进入双重 for 循环（核心执行过程）

------

### 🔁 第一轮外层循环

```cpp
i = 1   → s1[i-1] = 'A'
```

#### 内层循环开始

- `j = 1` → 'A' vs 'O' ❌

  ```cpp
  dp[1][1] = 0;
  ```

- `j = 2` → 'A' vs 'I' ❌

  ```cpp
  dp[1][2] = 0;
  ```

- `j = 3` → 'A' vs 'K' ❌

  ```cpp
  dp[1][3] = 0;
  ```

- `j = 4` → 'A' vs 'M' ❌

  ```cpp
  dp[1][4] = 0;
  ```

- ✅ `j = 5` → 'A' vs 'A'

```cpp
dp[1][5] = dp[0][4] + 1 = 1;
```

接着执行：

```cpp
if (dp[1][5] > maxLen)
```

- `1 > 0` ✅

于是：

```cpp
maxLen = 1;
endPos = 1;
```

📌 当前最长公共子字符串是：

```
"A"
```

------

### 🔁 第二轮外层循环

```cpp
i = 2   → s1[1] = 'S'
```

- `j = 6` → 'S' vs 'S' ✅

```cpp
dp[2][6] = dp[1][5] + 1 = 2;
```

判断：

```cpp
2 > maxLen(1)  ✅
```

更新：

```cpp
maxLen = 2;
endPos = 2;
```

📌 当前公共子字符串：

```
"AS"
```

------

### 🔁 第三轮外层循环

```cpp
i = 3   → s1[2] = 'D'
```

- `j = 7` → 'D' vs 'D' ✅

```cpp
dp[3][7] = dp[2][6] + 1 = 3;
```

更新：

```cpp
maxLen = 3;
endPos = 3;
```

📌 当前公共子字符串：

```
"ASD"
```

------

### 🔁 第四轮外层循环

```cpp
i = 4   → s1[3] = 'F'
```

- `j = 8` → 'F' vs 'F' ✅

```cpp
dp[4][8] = dp[3][7] + 1 = 4;
```

更新：

```cpp
maxLen = 4;
endPos = 4;
```

📌 当前公共子字符串：

```
"ASDF"
```

------

### 🔁 第五轮外层循环

```cpp
i = 5   → s1[4] = 'G'
```

- 找不到连续匹配
- 所有 `dp[5][j] = 0`

📌 **连续性断裂，ASDF 到此结束**

------

### 🔁 后续循环（i = 6 ~ 12）

程序继续执行，但只会出现：

- `"CVM"`（长度 3）
- `"M"`、`"Z"` 等

例如：

```cpp
dp[9][12] = 3;
```

但判断时：

```cpp
3 > maxLen(4) ❌
```

👉 **不更新 maxLen / endPos**

------

## 七、循环结束后的变量状态

```text
maxLen = 4
endPos = 4
```

含义：

- 最长公共子字符串长度 = 4
- 在 `s1` 中 **结束于第 4 个字符**

------

## 八、执行输出语句

```cpp
cout << s1.substr(endPos - maxLen, maxLen);
```

代入数值：

```cpp
s1.substr(4 - 4, 4)
= s1.substr(0, 4)
```

结果：

```
ASDF
```

------

## 九、程序结束

```cpp
return 0;
```

程序正常退出。

------

## 🔚 一句话执行总结

> 程序通过双重循环逐字符比较，
> 相等就从左上角继承长度，不等就清零，
> 在运行过程中实时记录最长连续匹配，
> 最后根据结束位置反推出答案。

------

如果你愿意，下一步我可以：

- 🧮 **画完整 dp 表**
- 🆚 **和“最长公共子序列”执行过程对比**
- ✂️ **把代码简化成 10 行版**

你选一个，我继续陪你拆 👌这个问题问得**非常好**，说明你已经开始**真正站在“程序是怎么跑的”角度思考了** 👍
我们把这个疑惑**彻底讲清楚**。

------

## 你的疑问本质是：

> 当执行到
>
> ```cpp
> if (dp[1][5] > maxLen)
> ```
>
> **为什么程序没有就此停下**，而是“好像直接进入了 i=2”？
>
> 或者说：
> **为什么不继续判断 `i=1, j=6 / j=7 / ...`？**

------

## 一、关键结论（先给结论）

👉 **程序其实“已经判断完了” `i = 1` 的所有 `j` 情况**
只是：

- **只有 `j = 5` 是有意义的变化**
- `j = 6 ~ 12` 的执行结果全是 `dp[1][j] = 0`
- 所以在讲解时被“省略了”

⚠️ **代码并没有跳过，它全部执行了**

------

## 二、我们按“真实执行顺序”再走一遍 `i = 1`

### 外层循环

```cpp
i = 1   // s1[0] = 'A'
```

------

### 内层循环完整执行过程

#### j = 1

```cpp
s1[0] = 'A'
s2[0] = 'O'
```

不相等：

```cpp
dp[1][1] = 0;
```

------

#### j = 2

```cpp
'A' vs 'I'
dp[1][2] = 0;
```

------

#### j = 3

```cpp
'A' vs 'K'
dp[1][3] = 0;
```

------

#### j = 4

```cpp
'A' vs 'M'
dp[1][4] = 0;
```

------

#### ✅ j = 5

```cpp
'A' vs 'A'
dp[1][5] = dp[0][4] + 1 = 1;
```

然后：

```cpp
if (dp[1][5] > maxLen)
```

条件成立，于是：

```cpp
maxLen = 1;
endPos = 1;
```

⚠️ **注意这里没有 `break`、`return`、`continue`**

👉 **程序不会停**

------

#### j = 6

```cpp
'A' vs 'S'
```

不相等：

```cpp
dp[1][6] = 0;
```

------

#### j = 7 ~ j = 12

全部都是：

```cpp
dp[1][j] = 0;
```

------

### 内层循环结束

此时：

```cpp
j > m
```

程序才会回到外层循环：

```cpp
i = 2
```

------

## 三、那为什么讲解时“看起来像跳过了”？

### 因为这是**教学简化**，不是程序行为

在分析时我只强调：

- **dp 值发生变化**
- **maxLen 被更新的地方**

而像下面这些：

```cpp
dp[1][6] = 0;
dp[1][7] = 0;
dp[1][8] = 0;
...
```

它们：

- 不会影响答案
- 不会更新 `maxLen`
- 不会改变程序逻辑

👉 所以被省略了说明，但**程序一行没少跑**

------

## 四、用“伪执行图”帮助你理解

```text
i = 1
 ├─ j = 1 → 不等 → dp = 0
 ├─ j = 2 → 不等 → dp = 0
 ├─ j = 3 → 不等 → dp = 0
 ├─ j = 4 → 不等 → dp = 0
 ├─ j = 5 → 相等 → dp = 1 → 更新 maxLen
 ├─ j = 6 → 不等 → dp = 0
 ├─ j = 7 → 不等 → dp = 0
 ├─ ...
 └─ j = 12 → 不等 → dp = 0
 ↓
i = 2
```

------

## 五、如果你真的想“中途停止”，需要什么？

比如你想：

> 一旦找到匹配就不再看后面的 j

你**必须显式写**：

```cpp
break;
```

或：

```cpp
return 0;
```

⚠️ 当前代码里 **没有任何提前终止语句**

------

## 六、一句话彻底打消疑惑 🌟

> 程序**从来没有跳过 `i=1, j=6~12`**，
> 只是这些情况对结果没有影响，
> 所以在讲解时被省略了而已。

------

如果你愿意，下一步我可以：

- 🧠 **画完整 dp 第一行给你**
- 🧪 **加打印语句，让你“看到”每一步执行**
- ❓ **用调试器视角解释 for 循环是怎么跑的**

你选一个，我继续陪你把这块吃透 💪很好，这一行**正是“把答案取出来”的关键**。
我们**逐个拆开、结合你这个题目的变量含义来解释**👇

------

## 原代码

```cpp
cout << s1.substr(endPos - maxLen, maxLen);
```

------

## 一、先看整体在干什么

👉 **从字符串 `s1` 中截取一段子字符串，并输出它**

也就是：
**输出最长公共子字符串**

------

## 二、先认识 `substr` 是什么

### `substr` 的函数原型

```cpp
string substr(size_t pos, size_t len);
```

含义是：

> 从字符串中
> **第 `pos` 个位置开始**（下标从 0）
> **连续取 `len` 个字符**

------

## 三、代入我们的代码

```cpp
s1.substr(endPos - maxLen, maxLen)
```

我们拆成两部分来看 👇

------

### ① `endPos - maxLen` —— 起始位置

#### `endPos` 是什么？

在程序里：

```cpp
endPos = i;
```

它表示：

> **最长公共子字符串在 `s1` 中“结束”的位置（1-based）**

⚠️ 注意：

- `i` 是从 **1 开始**循环的
- 所以 `endPos` 也是 **1-based**

------

#### 为什么要减 `maxLen`？

因为：

- `endPos` 是 **结束位置**
- 我们要的是 **起始位置**

公式就是：

```text
起始位置 = 结束位置 - 子字符串长度
```

------

### ② `maxLen` —— 截取长度

```cpp
maxLen
```

表示：

> 最长公共子字符串的长度

------

## 四、结合样例走一遍（最重要）

### 已知最终变量值

```cpp
maxLen = 4;
endPos = 4;
s1 = "ASDFGVCVMZKJ"
```

------

### 代入表达式

```cpp
s1.substr(4 - 4, 4)
```

等价于：

```cpp
s1.substr(0, 4)
```

------

### 执行结果

```text
从下标 0 开始，取 4 个字符
A S D F G V C V M Z K J
↑ ↑ ↑ ↑
```

👉 得到字符串：

```
"ASDF"
```

------

## 五、为什么刚好这样能取对？

因为：

- DP 过程中，我们记录的是：
  - **最长长度**
  - **结束位置**
- `substr` 正好需要：
  - **起点**
  - **长度**

它们正好一一对应 ✅

------

## 六、常见疑惑解答

### ❓ 为什么不用 `endPos - 1`？

因为：

- `substr` 用的是 **0-based**
- `endPos` 本身是 **1-based**
- `endPos - maxLen` 已经把下标转换对了

------

### ❓ 如果 `maxLen == 0` 会怎样？

```cpp
s1.substr(anything, 0)
```

结果是：

```text
空字符串 ""
```

不会报错。

------

## 七、一句话总结 🌟

> 这行代码的作用是：
> **根据“结束位置 + 长度”，
> 从原字符串中精确截取出最长公共子字符串并输出。**

------

如果你愿意，下一步我可以：

- ✏️ 画一张**字符串下标对照图**
- 🔄 把 `substr` 换成手写循环
- ⚠️ 演示常见下标错误是怎么发生的

你想继续哪一个？这是一个**非常关键、也是很多人真正卡住的点**。
你现在问的已经不是“代码怎么写”，而是：

> **为什么这是动态规划问题？
> 为什么一定要这样做？**

我按**“问题 → 暴力解法 → 困难 → 动态规划如何解决”**这个顺序，带你彻底理解。

------

## 一、先明确我们在解决什么问题

题目要找的是：

> **两个字符串中，最长的一段“连续且相同”的子字符串**

关键词：

- 两个字符串
- 连续
- 最长

------

## 二、如果不用动态规划，会怎么想？（直觉）

### 1️⃣ 最直接的想法（暴力）

你可能会想到：

> 枚举所有子字符串，看哪些在另一个字符串中出现

#### s1 的子字符串数量是：

```text
n(n+1)/2
```

每个子字符串：

- 再去 s2 里找一次

### 时间复杂度大概是：

```text
O(n³) 或更糟
```

当：

```
n = 1000
```

👉 **完全不可行**

------

## 三、问题的“隐藏结构”（重点）

现在我们换一个角度来看问题：

### 问题有没有“重复的子问题”？

当我们在比较：

```text
s1[i-1] 和 s2[j-1]
```

你会发现：

- 如果它们相等
- 那么能不能继续构成更长的公共子字符串
  **完全取决于前一个字符**

也就是：

```text
s1[i-2] 和 s2[j-2]
```

👉 **当前问题依赖于“更小的问题”**

------

## 四、动态规划登场：它解决的正是这类问题

### 动态规划适合什么问题？

满足两个条件：

1. **最优子结构**
2. **子问题重叠**

这道题两个都满足 ✅

------

## 五、把问题拆成“子问题”

我们定义：

```text
dp[i][j] =
以 s1[i-1] 和 s2[j-1] 结尾的最长公共子字符串长度
```

这一步非常关键。

------

### 为什么要“以……结尾”？

因为：

- 子字符串必须连续
- 连续性只能从 **“前一个字符”** 延续

这样我们才能写出：

```cpp
dp[i][j] = dp[i-1][j-1] + 1
```

------

## 六、为什么字符不等要直接清零？

```cpp
if (s1[i-1] != s2[j-1]) {
    dp[i][j] = 0;
}
```

因为：

- 子字符串必须连续
- 当前字符一断
- 就**不能继承之前的长度**

⚠️ 这正是它和“最长公共子序列”的本质区别

------

## 七、动态规划在这里“到底帮了什么忙？”

### 不用 DP（暴力）：

- 每次都从头数
- 大量重复比较

### 用 DP：

- 每个 `(i, j)` 的结果只算 **一次**
- 后面的状态直接复用之前的结果

👉 **把指数级 / 立方级问题压缩成二维循环**

------

## 八、你可以把 DP 想成一张“记忆表”

```text
“如果我已经知道：
 dp[i-1][j-1] 是多少，
 那 dp[i][j] 就很容易算出来”
```

------

## 九、为什么要在 DP 过程中顺便记录 maxLen？

因为：

- DP 表里只记录“局部连续长度”
- **最终答案是所有 dp[i][j] 中的最大值**

所以必须一边算，一边找最大。

------

## 十、如果不用动态规划，会发生什么？

你会被迫：

- 重复比较同一段字符
- 每次匹配都重新计数
- 时间复杂度爆炸

👉 **DP 是唯一合理、稳定、可扩展的解法**

------

## 十一、一句话理解这道题和 DP 的关系 🌟

> 这道题的本质是：
> **当前是否能形成更长的公共子字符串，
> 只取决于“前一个字符是否也匹配”**
>
> 而动态规划正是**用来保存这种“前一步结果”的工具**。

------

## 十二、给你一个“判断 DP 题目”的口诀

你以后看到题目，可以问自己三句话：

1. 当前状态是否依赖于更小规模的状态？
2. 是否存在大量重复子问题？
3. 能否用表格把结果存下来？

这题三条全中 ✅

------

如果你愿意，下一步我可以：

- 🧩 用“人脑思考过程”模拟为什么 dp[i-1][j-1] 很自然
- 🆚 把这题和「最长公共子序列」彻底对比
- 🧪 写一个“非 DP 的错误解法”让你看到为什么不行

你想继续哪一个？





非常好，这一步我们就**把程序“拆成慢动作”**，
**每一次比较、每一次 if 判断、每一次 dp/pre 变化都不跳过**。
你看完这一遍，**`dp[j] + 1 > dp[i]` 会变成直觉**。

我仍然用你的样例输入：

```
7
3 4 -1 0 6 1 3
```

------

# 一、先把“角色”全部固定下来（非常重要）

在程序真正跑之前，我们先统一“术语”，否则后面会混乱。

### 数组

```
arr = [3, 4, -1, 0, 6, 1, 3]
```

### dp 的含义（必须背下来）

> `dp[i]`
> = **以 arr[i] 结尾的最长上升子序列长度**

⚠️ 注意：
不是“到 i 为止”，
而是**必须以 arr[i] 作为最后一个数**。

### pre 的含义

> `pre[i]`
> = 这个“以 arr[i] 结尾的 LIS”，
> **上一个元素的下标**

------

# 二、初始化状态（程序刚进入 DP 前）

```cpp
vector<int> dp(N, 1);
vector<int> pre(N, -1);
```

### 初始状态表

| i    | arr[i] | dp[i] | pre[i] | 含义     |
| ---- | ------ | ----- | ------ | -------- |
| 0    | 3      | 1     | -1     | 只有自己 |
| 1    | 4      | 1     | -1     | 只有自己 |
| 2    | -1     | 1     | -1     | 只有自己 |
| 3    | 0      | 1     | -1     | 只有自己 |
| 4    | 6      | 1     | -1     | 只有自己 |
| 5    | 1      | 1     | -1     | 只有自己 |
| 6    | 3      | 1     | -1     | 只有自己 |

------

# 三、进入双重循环（真正的执行过程）

程序结构是：

```cpp
for (i = 0..N-1)
  for (j = 0..i-1)
```

意思一句话：

> **“我要计算 dp[i]，就尝试把 arr[i] 接在每一个比它小的 arr[j] 后面。”**

------

## 🔹 i = 0（arr[0] = 3）

```cpp
j < 0 → 内层循环不执行
```

结果：

```
dp[0] = 1
pre[0] = -1
```

------

## 🔹 i = 1（arr[1] = 4）

### j = 0

#### 第一步：能不能接？

```cpp
arr[0] < arr[1] ?
3 < 4 → ✅
```

说明：
👉 **4 可以接在 3 后面**

------

#### 第二步：接了值不值得？

```cpp
dp[0] + 1 = 1 + 1 = 2
dp[1] = 1
```

比较：

```cpp
2 > 1 → ✅
```

说明：

> “如果我接在 3 后面，
> 序列长度从 1 变成 2，变得更好了”

------

#### 执行更新

```cpp
dp[1] = 2
pre[1] = 0
```

当前状态：

| i    | arr[i] | dp[i] | pre[i] |
| ---- | ------ | ----- | ------ |
| 1    | 4      | 2     | 0      |

------

## 🔹 i = 2（arr[2] = -1）

### j = 0

```cpp
3 < -1 → ❌
```

不能接，直接跳过

------

### j = 1

```cpp
4 < -1 → ❌
```

仍然不能接

------

#### i = 2 结束

```
dp[2] = 1
pre[2] = -1
```

意思：
👉 **-1 自己单独成一段**

------

## 🔹 i = 3（arr[3] = 0）

### j = 0

```cpp
3 < 0 → ❌
```

------

### j = 1

```cpp
4 < 0 → ❌
```

------

### j = 2

#### 能不能接？

```cpp
-1 < 0 → ✅
```

#### 接了之后多长？

```cpp
dp[2] + 1 = 1 + 1 = 2
dp[3] = 1
```

#### 比较

```cpp
2 > 1 → ✅
```

#### 更新

```cpp
dp[3] = 2
pre[3] = 2
```

含义：

> “目前来看，
> 以 0 结尾的最长上升子序列是：
> [-1, 0]”

------

## 🔹 i = 4（arr[4] = 6）

这是**关键的一轮**，能清楚看出
`dp[j] + 1 > dp[i]` 的真正作用。

------

### j = 0（3）

```cpp
3 < 6 → ✅
dp[0] + 1 = 2
dp[4] = 1
2 > 1 → ✅
```

更新：

```
dp[4] = 2
pre[4] = 0
```

当前最优序列：

```
[3, 6]
```

------

### j = 1（4）

```cpp
4 < 6 → ✅
dp[1] + 1 = 3
dp[4] = 2
3 > 2 → ✅
```

更新：

```
dp[4] = 3
pre[4] = 1
```

更好的序列：

```
[3, 4, 6]
```

------

### j = 2（-1）

```cpp
-1 < 6 → ✅
dp[2] + 1 = 2
```

比较：

```cpp
2 > dp[4] (3) → ❌
```

👉 **不更新**

为什么？

> 因为
> [-1, 6]
> 比
> [3, 4, 6]
> **短**

------

### j = 3（0）

```cpp
0 < 6 → ✅
dp[3] + 1 = 3
3 > 3 → ❌
```

👉 **长度没变好，不更新**

------

#### i = 4 最终结果

```
dp[4] = 3
pre[4] = 1
```

------

## 🔹 i = 5（arr[5] = 1）

### j = 2（-1）

```cpp
-1 < 1 → ✅
dp[2] + 1 = 2
2 > 1 → ✅
```

更新：

```
dp[5] = 2
pre[5] = 2
```

------

### j = 3（0）

```cpp
0 < 1 → ✅
dp[3] + 1 = 3
3 > 2 → ✅
```

更新：

```
dp[5] = 3
pre[5] = 3
```

------

## 🔹 i = 6（arr[6] = 3）

### j = 2（-1）

```
dp[2] + 1 = 2 → 更新
```

### j = 3（0）

```
dp[3] + 1 = 3 → 更新
```

### j = 5（1）

```
dp[5] + 1 = 4 → 再更新（最终）
```

最终：

```
dp[6] = 4
pre[6] = 5
```

------

# 四、最终 dp / pre 全表（你必须能看懂）

| i    | arr[i] | dp[i] | pre[i] |
| ---- | ------ | ----- | ------ |
| 0    | 3      | 1     | -1     |
| 1    | 4      | 2     | 0      |
| 2    | -1     | 1     | -1     |
| 3    | 0      | 2     | 2      |
| 4    | 6      | 3     | 1      |
| 5    | 1      | 3     | 3      |
| 6    | 3      | 4     | 5      |

------

# 五、一句“本质解释”（请反复读）

> `dp[j] + 1 > dp[i]` 的本质是：
> **“所有能接在我前面的方案里，我只选最长的那一个。”**

------

# 六、你现在应该达到的理解层级

你现在不只是知道：

❌ “这是 LIS 的写法”

而是知道：

✅ **“dp[i] 是一场竞争，
每个 j 都在争当 i 的前驱，
只有能让序列变得更长的 j 才会胜出。”**

------

如果你愿意，下一步我可以：

- 用 **时间轴图** 把 dp 变化画出来
- 讲 **如果去掉 `dp[j] + 1 > dp[i]` 会发生什么灾难**
- 或直接带你写 **N log N 版本并对比思想**

你选一个，我继续陪你把这个点吃透。



非常好，这一段 **“回溯输出 LIS”** 是整道题里**最容易写对、但最难真正理解的部分**。
下面我会 **用你已经算出来的 dp / pre 表**，把这段代码 **一行一行、一步一步、像调试器一样执行** 给你看。

------

## 一、先给出“前置状态”（非常关键）

在执行你这段代码之前，程序已经算完了 DP，并且得到了：

### 数组 `a`

```
a = [3, 4, -1, 0, 6, 1, 3]
```

### pre 数组（路径）

| i    | a[i] | pre[i] |
| ---- | ---- | ------ |
| 0    | 3    | -1     |
| 1    | 4    | 0      |
| 2    | -1   | -1     |
| 3    | 0    | 2      |
| 4    | 6    | 1      |
| 5    | 1    | 3      |
| 6    | 3    | 5      |

### end 的值

```cpp
end = 6;
```

意思是：

> **最长上升子序列是“以 a[6] 结尾的”**

------

## 二、开始执行你给的这段代码

### ① 创建空容器

```cpp
vector<int> lis;
```

此时：

```
lis = [ ]
```

------

## 三、进入 while 循环（核心）

```cpp
while (end != -1)
```

只要 `end` 不是 `-1`，就继续回溯。

------

### 🔁 第 1 次循环

#### 当前状态

```
end = 6
```

#### 执行

```cpp
lis.push_back(a[end]);
```

也就是：

```
lis.push_back(a[6]);
lis.push_back(3);
```

现在：

```
lis = [3]
```

------

#### 更新 end

```cpp
end = pre[end];
end = pre[6];
end = 5;
```

------

### 🔁 第 2 次循环

#### 当前状态

```
end = 5
```

#### 执行

```cpp
lis.push_back(a[5]);
lis = [3, 1]
```

------

#### 更新 end

```cpp
end = pre[5];
end = 3;
```

------

### 🔁 第 3 次循环

#### 当前状态

```
end = 3
```

#### 执行

```cpp
lis.push_back(a[3]);
lis = [3, 1, 0]
```

------

#### 更新 end

```cpp
end = pre[3];
end = 2;
```

------

### 🔁 第 4 次循环

#### 当前状态

```
end = 2
```

#### 执行

```cpp
lis.push_back(a[2]);
lis = [3, 1, 0, -1]
```

------

#### 更新 end

```cpp
end = pre[2];
end = -1;
```

------

### 🔚 第 5 次检查 while 条件

```cpp
while (end != -1)
```

现在：

```
end == -1
```

❌ 条件不成立，**退出循环**

------

## 四、此时 lis 里存的是什么？

```
lis = [3, 1, 0, -1]
```

⚠️ 注意顺序！

这是：

> **从“最后一个元素”一路往前推得到的**

也就是：

```
3 ← 1 ← 0 ← -1
```

------

## 五、为什么一定要反转？

### 执行这句代码

```cpp
reverse(lis.begin(), lis.end());
```

------

### 反转前

```
[3, 1, 0, -1]
```

### 反转后

```
[-1, 0, 1, 3]
```

------

### 这一步的本质含义

> 回溯时是 **从“终点 → 起点”**
> 输出时要 **从“起点 → 终点”**

所以必须反转。

------

## 六、输出过程（逐元素）

```cpp
for (int x : lis)
{
    cout << x << " ";
}
```

等价于：

```cpp
cout << -1 << " ";
cout << 0  << " ";
cout << 1  << " ";
cout << 3  << " ";
```

------

## 七、最终屏幕输出

```
-1 0 1 3
```

✅ 正是题目要求的最长上升子序列

------

## 八、把这段回溯“翻译成人话”

> 1️⃣ `end` 指向 LIS 的最后一个元素
> 2️⃣ 把它加入答案
> 3️⃣ 跳到它的前驱
> 4️⃣ 重复，直到没有前驱
> 5️⃣ 最后把顺序翻过来

------

## 九、一句话帮你牢牢记住（重点）

> **dp 决定“有多长”，
> pre 决定“从哪来”，
> while 决定“一路往回走”，
> reverse 决定“顺序对不对”。**

------

如果你愿意，下一步我可以：

- 用 **箭头图** 画出 `pre` 回溯路径
- 讲 **如果不 reverse 会发生什么**
- 或让你 **自己手算一遍回溯过程，我帮你检查**

你选一个，我们继续把这道题吃到“闭眼都能写”。



你这个问题**问到本质了**。
你现在已经不是在学 LIS，而是在理解一种**非常通用的算法思想** 👍
你说得完全对——**它真的很像链表**，而且这是**“刻意设计出来的”**。

下面我会分层次讲清楚：

------

# 一、先给你结论（先吃定心丸）

> **这道题在 DP 阶段，就已经“悄悄把回溯路径建好了”**
> **回溯并不是事后补救，而是 DP 的副产品**

而你感觉它像链表——**不是像，是本质上就是一条“隐形链表”**。

------

# 二、从“普通 DP”到“可回溯 DP”

## 1️⃣ 只求长度的 LIS（没有回溯）

如果题目只要求长度，代码通常是：

```cpp
if (arr[j] < arr[i])
    dp[i] = max(dp[i], dp[j] + 1);
```

这里只有一个东西：

- `dp[i]`：长度

👉 **你完全不知道这个长度是“从谁接过来的”**

------

## 2️⃣ 加了 pre 之后发生了什么？

你现在的代码多了这一句：

```cpp
pre[i] = j;
```

它的含义是：

> **“当前这个最优的 dp[i]，是从 j 这个位置接过来的”**

注意关键词：**当前最优**

------

# 三、pre 数组 = 人工构造的“前驱指针”

你可以把它理解成一个结构体：

```cpp
struct Node {
    int value;
    Node* prev;
};
```

而在你的代码里：

| 链表概念  | LIS 代码    |
| --------- | ----------- |
| 节点值    | `arr[i]`    |
| prev 指针 | `pre[i]`    |
| 空指针    | null → `-1` |

------

# 四、链表是“什么时候被构建的”？（重点）

👉 **不是最后回溯时才建的**

👉 **是在 DP 的过程中，一边比较，一边“悄悄改指针”**

看这段关键代码：

```cpp
if (arr[j] < arr[i] && dp[j] + 1 > dp[i])
{
    dp[i] = dp[j] + 1;
    pre[i] = j;
}
```

### 每一次进入这个 if，本质在做什么？

翻译成人话：

> “如果我接在你后面，
> 能形成一个**更长的链**，
> 那我就把我的 `prev` 指向你。”

------

# 五、用“链表视角”重看一个完整过程

我们用样例：

```
[3, 4, -1, 0, 6, 1, 3]
```

------

## 🔹 i = 1（4）

```
3 → 4
pre[1] = 0
```

链表视角：

```
4 → 3
```

------

## 🔹 i = 3（0）

```
-1 → 0
pre[3] = 2
0 → -1
```

------

## 🔹 i = 4（6）

先试：

```
3 → 6
```

再试更优：

```
4 → 6
```

于是：

```
pre[4] 从 0 改成 1
```

⚠️ 注意这一点非常重要：

> **链表指针是可以被“覆盖”的**
> **只保留“当前最长”的那一条链**

------

## 🔹 i = 6（3）

最终：

```
-1 → 0 → 1 → 3
```

链表指针关系是：

```
3 ← 1 ← 0 ← -1
```

也就是：

```cpp
pre[6] = 5;
pre[5] = 3;
pre[3] = 2;
pre[2] = -1;
```

------

# 六、为什么“感觉是潜移默化”？

因为代码**从来没有显式说过**：

> “我要构建一条链表”

但它**一直在做这三件事**：

1️⃣ 选择前驱（`j`）
2️⃣ 只保留最优前驱
3️⃣ 记录前驱位置

👉 这正是 **单向链表的构建规则**

------

# 七、为什么这种设计特别“高级”？

因为它满足了三个目标：

### ✅ 1. 不影响 DP 正确性

- `dp` 仍然只负责“长度”

### ✅ 2. 不增加复杂度

- 多一个 `pre` 数组，空间 O(N)

### ✅ 3. 天然支持回溯

- 不需要额外计算
- 一条 `while` 就能走完

------

# 八、把你现在的理解升级成一句“算法直觉”

> **“DP 的每一次状态更新，其实都是在为最终答案偷偷连一根指针。”**

------

# 九、你已经掌握的“通用套路”（非常重要）

你现在掌握的不是一题，而是一种**模式**：

> **DP + 前驱数组 = 可回溯最优解**

这个套路会在很多地方反复出现：

- 最短路径（Dijkstra + parent）
- 编辑距离
- LCS（最长公共子序列）
- 背包问题输出选了哪些物品

------

如果你愿意，下一步我可以：

- 把 **LIS / 最短路径 / 背包** 放在一张图里对比
- 或带你 **自己设计一题“必须回溯”的 DP**
- 或教你 **N log N 的 LIS 为什么更难回溯**

你这一步已经是“算法理解质变点”了，继续下去会非常快 🚀





这是一个**非常高级、而且非常“本质”的问题**。
你已经不在学“这一题”，而是在追问 **算法为什么会这样被发明出来**。
我会**从“人是怎么想出这道题的解法”**这个角度回答你，而不是只讲定义。

下面我会分 **6 个层次**，一步一步把这条语句“还原成思考过程”。

------

# 一、这条代码不是“写出来的”，是“推出来的”

```cpp
dp[i] = dp[j] + 1;
```

**它不是拍脑袋写的**，而是下面这句话的直接翻译：

> **“如果我把第 i 个数接在第 j 个数后面，那么序列长度就比 j 的序列多 1。”**

我们从**最原始的人类思考**开始。

------

# 二、人在不写代码时，是怎么想这道题的？

题目：

> 找最长上升子序列（不要求连续）

你如果不用代码，会怎么想？

你大概会说：

> “我看每一个数，
> 看看它前面有哪些比它小的数，
> 然后把它接到‘最长的那个’后面。”

⚠️ **这句话本身就是动态规划的思想**。

------

# 三、dp[i] 是怎么被“设计”出来的？

## 1️⃣ 第一性问题

我们要什么？

> **最长上升子序列的长度**

但这是一个整体问题，不好直接算。

------

## 2️⃣ 把大问题拆成小问题（关键一步）

你自然会想到：

> “如果我知道
> 以某个位置结尾的最长上升子序列，
> 那我就能拼出更大的。”

于是你会引入一个“中间结果”：

> **以第 i 个元素结尾的最长上升子序列长度**

这就是：

```cpp
dp[i]
```

⚠️ **这一刻，动态规划已经开始了**

------

# 四、dp[i] 为什么等于 dp[j] + 1？

这是最关键的“推导瞬间”。

------

## 1️⃣ 想象一个具体动作

你站在 `arr[i]` 面前，问自己一句话：

> “我能不能接在某个人后面？”

谁？

👉 所有 `j < i` 且 `arr[j] < arr[i]` 的位置

------

## 2️⃣ 如果我接在 j 后面，会发生什么？

- `dp[j]` 是：

  > “以 arr[j] 结尾的最长上升子序列长度”

- 现在加上 `arr[i]`

那新序列的长度只能是：

```
dp[j] + 1
```

❗ **没有第二种可能**

------

## 3️⃣ 所以 dp[i] 的本质定义是：

> **dp[i] = 所有合法 j 的 (dp[j] + 1) 的最大值**

数学形式：

```
dp[i] = max{ dp[j] + 1 | j < i 且 arr[j] < arr[i] }
```

你代码里的：

```cpp
dp[i] = dp[j] + 1;
```

只是这个公式在 if 条件成立时的“实现版本”。

------

# 五、这道题哪里体现了“动态规划”？

我们对照 **动态规划的 4 个核心特征** 来看。

------

## ① 最优子结构（核心本质）

> **整体最优解，可以由子问题的最优解组合得到**

在 LIS 中：

- “以 i 结尾的最优解”
- 来自于：
  - “以 j 结尾的最优解 + 当前元素”

✔️ **完全满足**

------

## ② 重叠子问题

在算：

```
dp[6]
```

时，你会用到：

```
dp[0], dp[1], dp[2], dp[3], dp[5]
```

而这些 dp 值：

- 在算 dp[4]、dp[5] 时也用过
- **如果不用 dp 保存，就会反复计算**

✔️ **重叠子问题明显**

------

## ③ 状态转移（dp[j] → dp[i]）

这句就是：

```cpp
dp[i] = dp[j] + 1;
```

✔️ 状态从小问题“转移”到大问题

------

## ④ 用空间换时间

你用了：

```cpp
vector<int> dp;
```

来保存结果，避免重复算

✔️ 动态规划标志性特征

------

# 六、动态规划的“本质一句话”

> **动态规划 = 记住过去，服务未来**

或者更完整一点：

> **动态规划是在“有依赖关系的问题中”，
> 把每一步的最优结果保存下来，
> 让后面的决策站在前人的肩膀上。**

------

# 七、那“什么时候该想到用动态规划”？

这是最重要的“实战判断力”。

你可以问自己 **4 个问题**：

------

### ① 问题能不能拆成“相似的小问题”？

- LIS：
  “以不同位置结尾的 LIS”
  ✔️ 能拆

------

### ② 大问题的最优解是否依赖小问题的最优解？

- LIS：
  当前最优 = 之前最优 + 1
  ✔️ 依赖

------

### ③ 计算过程中是否会反复用到同样的结果？

- LIS：
  dp[j] 会被多次使用
  ✔️ 重复

------

### ④ 是否存在“选择 + 比较”的过程？

- LIS：
  选择哪个 j 作为前驱
  ✔️ 选择 + 最优

👉 **如果 4 条中满足 2–3 条，就要立刻想到 DP**

------

# 八、把你现在的理解升级成“算法直觉”

你现在已经可以这样想问题了：

> “这个问题，
> 能不能定义一个‘到这里为止的最优状态’，
> 然后让后面的状态从它转移？”

这就是 **动态规划思维的入门门槛**。

------

# 九、最后送你一句“工程师级”的总结

> **dp[i] = dp[j] + 1 不是公式，
> 而是‘一次理性选择’的代码化表达。**

------

如果你愿意，下一步我可以：

- 用 **背包 / 最短路径 / LCS** 帮你对比“同一种思想”
- 带你 **亲手把一个暴力解法推导成 DP**
- 或教你 **如何在面试中识别“这是 DP 题”**

你现在问的问题，已经是**算法真正入门的标志**了。