# 蛇形填数代码详细执行过程（输入：3 3）

## 1. 初始化和输入
```cpp
int n, m;
cin >> n >> m;  // 用户输入 3 3
// n = 3, m = 3
```

## 2. 创建矩阵
```cpp
vector<vector<int>> matrix(n, vector<int>(m, 0));
```
创建 3×3 矩阵，所有元素初始化为 0：
```
matrix = [
  [0, 0, 0],
  [0, 0, 0],
  [0, 0, 0]
]
```

## 3. 方向数组初始化
```cpp
int dx[4] = {0, 1, 0, -1};  // 行变化：0,1,0,-1
int dy[4] = {1, 0, -1, 0};  // 列变化：1,0,-1,0
// 对应四个方向：右(0,1)、下(1,0)、左(0,-1)、上(-1,0)
```

## 4. 初始位置和方向
```cpp
int x = 0, y = 0;    // 起始位置：(0,0)
int dir = 0;         // 起始方向：0（向右）
```

## 5. 主循环 - 填充数字 1 到 9

### **第1次循环** (i = 1)
```cpp
matrix[x][y] = i;    // matrix[0][0] = 1
```
矩阵变为：
```
[1, 0, 0]
[0, 0, 0]
[0, 0, 0]
```

```cpp
int nx = x + dx[dir];  // nx = 0 + 0 = 0
int ny = y + dy[dir];  // ny = 0 + 1 = 1
```
下一个位置：(0,1)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(0,1)不越界且matrix[0][1]=0，条件为false
    // 不进入if块
}
```

```cpp
x = nx;  // x = 0
y = ny;  // y = 1
```
更新后位置：(0,1)

---

### **第2次循环** (i = 2)
```cpp
matrix[x][y] = i;    // matrix[0][1] = 2
```
矩阵变为：
```
[1, 2, 0]
[0, 0, 0]
[0, 0, 0]
```

```cpp
int nx = x + dx[dir];  // nx = 0 + 0 = 0
int ny = y + dy[dir];  // ny = 1 + 1 = 2
```
下一个位置：(0,2)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(0,2)不越界且matrix[0][2]=0，条件为false
    // 不进入if块
}
```

```cpp
x = nx;  // x = 0
y = ny;  // y = 2
```
更新后位置：(0,2)

---

### **第3次循环** (i = 3)
```cpp
matrix[x][y] = i;    // matrix[0][2] = 3
```
矩阵变为：
```
[1, 2, 3]
[0, 0, 0]
[0, 0, 0]
```

```cpp
int nx = x + dx[dir];  // nx = 0 + 0 = 0
int ny = y + dy[dir];  // ny = 2 + 1 = 3
```
下一个位置：(0,3) ❌ **注意：y=3超出了列范围**

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：ny=3 >= m(3)，条件为true，进入if块
    
    dir = (dir + 1) % 4;  // dir = (0 + 1) % 4 = 1（改为向下）
    
    nx = x + dx[dir];  // nx = 0 + 1 = 1（使用新方向重新计算）
    ny = y + dy[dir];  // ny = 2 + 0 = 2
}
```
现在下一个位置是：(1,2)

```cpp
x = nx;  // x = 1
y = ny;  // y = 2
```
更新后位置：(1,2)

---

### **第4次循环** (i = 4)
```cpp
matrix[x][y] = i;    // matrix[1][2] = 4
```
矩阵变为：
```
[1, 2, 3]
[0, 0, 4]
[0, 0, 0]
```

```cpp
int nx = x + dx[dir];  // dir=1（向下）：nx = 1 + 1 = 2
int ny = y + dy[dir];  // ny = 2 + 0 = 2
```
下一个位置：(2,2)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(2,2)不越界且matrix[2][2]=0，条件为false
    // 不进入if块
}
```

```cpp
x = nx;  // x = 2
y = ny;  // y = 2
```
更新后位置：(2,2)

---

### **第5次循环** (i = 5)
```cpp
matrix[x][y] = i;    // matrix[2][2] = 5
```
矩阵变为：
```
[1, 2, 3]
[0, 0, 4]
[0, 0, 5]
```

```cpp
int nx = x + dx[dir];  // dir=1（向下）：nx = 2 + 1 = 3
int ny = y + dy[dir];  // ny = 2 + 0 = 2
```
下一个位置：(3,2) ❌ **注意：x=3超出了行范围**

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：nx=3 >= n(3)，条件为true，进入if块
    
    dir = (dir + 1) % 4;  // dir = (1 + 1) % 4 = 2（改为向左）
    
    nx = x + dx[dir];  // nx = 2 + 0 = 2（使用新方向重新计算）
    ny = y + dy[dir];  // ny = 2 + (-1) = 1
}
```
现在下一个位置是：(2,1)

```cpp
x = nx;  // x = 2
y = ny;  // y = 1
```
更新后位置：(2,1)

---

### **第6次循环** (i = 6)
```cpp
matrix[x][y] = i;    // matrix[2][1] = 6
```
矩阵变为：
```
[1, 2, 3]
[0, 0, 4]
[0, 6, 5]
```

```cpp
int nx = x + dx[dir];  // dir=2（向左）：nx = 2 + 0 = 2
int ny = y + dy[dir];  // ny = 1 + (-1) = 0
```
下一个位置：(2,0)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(2,0)不越界且matrix[2][0]=0，条件为false
    // 不进入if块
}
```

```cpp
x = nx;  // x = 2
y = ny;  // y = 0
```
更新后位置：(2,0)

---

### **第7次循环** (i = 7)
```cpp
matrix[x][y] = i;    // matrix[2][0] = 7
```
矩阵变为：
```
[1, 2, 3]
[0, 0, 4]
[7, 6, 5]
```

```cpp
int nx = x + dx[dir];  // dir=2（向左）：nx = 2 + 0 = 2
int ny = y + dy[dir];  // ny = 0 + (-1) = -1
```
下一个位置：(2,-1) ❌ **注意：y=-1超出了列范围**

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：ny=-1 < 0，条件为true，进入if块
    
    dir = (dir + 1) % 4;  // dir = (2 + 1) % 4 = 3（改为向上）
    
    nx = x + dx[dir];  // nx = 2 + (-1) = 1（使用新方向重新计算）
    ny = y + dy[dir];  // ny = 0 + 0 = 0
}
```
现在下一个位置是：(1,0)

```cpp
x = nx;  // x = 1
y = ny;  // y = 0
```
更新后位置：(1,0)

---

### **第8次循环** (i = 8)
```cpp
matrix[x][y] = i;    // matrix[1][0] = 8
```
矩阵变为：
```
[1, 2, 3]
[8, 0, 4]
[7, 6, 5]
```

```cpp
int nx = x + dx[dir];  // dir=3（向上）：nx = 1 + (-1) = 0
int ny = y + dy[dir];  // ny = 0 + 0 = 0
```
下一个位置：(0,0)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(0,0)不越界但matrix[0][0]=1≠0，条件为true，进入if块
    
    dir = (dir + 1) % 4;  // dir = (3 + 1) % 4 = 0（改为向右）
    
    nx = x + dx[dir];  // nx = 1 + 0 = 1（使用新方向重新计算）
    ny = y + dy[dir];  // ny = 0 + 1 = 1
}
```
现在下一个位置是：(1,1)

```cpp
x = nx;  // x = 1
y = ny;  // y = 1
```
更新后位置：(1,1)

---

### **第9次循环** (i = 9)
```cpp
matrix[x][y] = i;    // matrix[1][1] = 9
```
矩阵变为：
```
[1, 2, 3]
[8, 9, 4]
[7, 6, 5]
```

```cpp
int nx = x + dx[dir];  // dir=0（向右）：nx = 1 + 0 = 1
int ny = y + dy[dir];  // ny = 1 + 1 = 2
```
下一个位置：(1,2)

```cpp
if (nx < 0 || nx >= n || ny < 0 || ny >= m || matrix[nx][ny] != 0) {
    // 检查：(1,2)不越界但matrix[1][2]=4≠0，条件为true，进入if块
    
    dir = (dir + 1) % 4;  // dir = (0 + 1) % 4 = 1（改为向下）
    
    nx = x + dx[dir];  // nx = 1 + 1 = 2
    ny = y + dy[dir];  // ny = 1 + 0 = 1
}
```
现在下一个位置是：(2,1)

```cpp
x = nx;  // x = 2
y = ny;  // y = 1
```
更新后位置：(2,1)

---

### **循环结束** (i = 10 > 9)
循环条件 `i <= n * m` (i <= 9) 不再满足，退出循环。

## 6. 输出结果
```cpp
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        cout << matrix[i][j] << " ";
    }
    cout << endl;
}
```
输出：
```
1 2 3
8 9 4
7 6 5
```

## 关键点总结：
1. **轨迹路线**：(0,0)→(0,1)→(0,2)→(1,2)→(2,2)→(2,1)→(2,0)→(1,0)→(1,1)
2. **方向变化**：右→右(越界)→下→下(越界)→左→左(越界)→上→上(被占)→右
3. **边界处理**：检测越界和已填充位置，及时改变方向
4. **填数完成**：恰好填充9个数字后结束




# 蛇形填数问题的原理与思想

## 1. **问题本质：空间填充的路径规划**

这道题的核心是：**如何按照特定规则遍历一个二维网格的所有位置**。

### 关键特点：
- 遍历顺序不是常规的行优先或列优先
- 遍历路径是螺旋状的，像蛇一样盘旋
- 需要动态调整前进方向

## 2. **核心思想：状态机 + 边界检测**

### **状态机思想**
程序维护一个"当前状态"：
- **当前位置** (x, y)
- **当前方向** (dir)

状态转移规则：
1. 在当前位置填入数字
2. 尝试按当前方向前进
3. 如果前进受阻，改变方向
4. 更新位置到下一个状态

### **四种状态（方向）**
```cpp
dir = 0: 向右移动 (dx=0, dy=1)
dir = 1: 向下移动 (dx=1, dy=0)  
dir = 2: 向左移动 (dx=0, dy=-1)
dir = 3: 向上移动 (dx=-1, dy=0)
```

方向转换使用模运算：
```cpp
dir = (dir + 1) % 4  // 顺时针旋转90度
```

## 3. **边界检测的双重意义**

边界检测不仅是防止数组越界，还定义了填充的"生长边界"：

### **两种边界条件**
```cpp
// 1. 物理边界（数组边界）
nx < 0 || nx >= n || ny < 0 || ny >= m

// 2. 逻辑边界（已填充区域）
matrix[nx][ny] != 0
```

### **物理边界的意义**
- 确保程序不会访问非法内存
- 定义了螺旋的外围边界

### **逻辑边界的意义**
- 已填充的区域形成了一道"墙"
- 蛇不能穿过自己已经走过的路径
- 这导致路径向内螺旋收缩

## 4. **模拟与迭代的思想**

### **模拟（Simulation）方法**
- 不依赖数学公式直接计算位置
- 通过"一步接一步"的模拟来构建结果
- 每一步都基于当前状态决定下一步

### **迭代（Iteration）过程**
```
初始化位置和方向
for 每个数字从1到n×m:
    1. 在当前格子填入数字
    2. 计算下一个位置
    3. 如果下一个位置无效，改变方向并重新计算
    4. 移动到下一个位置
```

## 5. **空间划分的思想**

### **螺旋形路径的几何意义**
- 外层螺旋 → 内层螺旋 → 最中心
- 类似于"剥洋葱"，一层一层向内
- 每次碰到边界就"转弯"

### **四个转弯点的规律**
```
右转下：(0, m-1)      // 第一行最后一列
下转左：(n-1, m-1)    // 最后一行最后一列  
左转上：(n-1, 0)      // 最后一行第一列
上转右：(已填充区域)   // 碰到已填充格子
```

## 6. **方向向量的巧妙运用**

### **方向向量表示法**
```cpp
dx[4] = {0, 1, 0, -1}
dy[4] = {1, 0, -1, 0}
```

### **优点：**
1. **统一处理**：所有方向用同一套代码处理
2. **易于扩展**：增加方向只需扩展数组
3. **清晰易懂**：方向变化就是索引变化

## 7. **算法的时间与空间复杂度**

### **时间复杂度**：O(n×m)
- 每个格子只访问一次
- 每次访问进行常数次操作

### **空间复杂度**：O(n×m)
- 存储矩阵需要 n×m 的空间
- 额外变量是常数空间

## 8. **与其他算法的对比**

### **与DFS/BFS的区别**
- 不需要递归或队列
- 前进方向有确定性规则（右→下→左→上）
- 没有回溯，是单向填充

### **与数学公式法的区别**
- 数学法：根据坐标(i,j)直接计算值
- 模拟法：通过过程推导结果
- 模拟法更直观易懂

## 9. **实际应用场景**

这种算法思想可以应用于：
1. **图像处理**：螺旋遍历像素
2. **矩阵操作**：螺旋打印矩阵
3. **游戏开发**：蛇形移动、地图探索
4. **内存管理**：螺旋分配内存空间
5. **路径规划**：避障路径生成

## 10. **教学意义**

这道题训练了：
1. **二维数组操作能力**
2. **边界条件处理能力**
3. **状态转换思维**
4. **模拟算法设计能力**
5. **循环与条件判断的综合运用**

## 总结

蛇形填数问题的核心思想是：**通过维护状态（位置和方向）和检测边界，按照预定规则（右→下→左→上）遍历二维空间**。它体现了计算思维中的**模拟、状态机和迭代**思想，是学习算法设计的经典入门题目。

这种"碰壁转向"的策略在计算机科学中很常见，类似于：
- 扫地机器人的避障算法
- 迷宫求解的右手法则
- 图形填充的扫描线算法
